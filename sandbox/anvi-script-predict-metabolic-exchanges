#!/usr/bin/env python
# -*- coding: utf-8

import sys
import anvio
import anvio.utils as utils
import anvio.kgml as kgml
import anvio.terminal as terminal
import anvio.reactionnetwork as rn
import anvio.kgmlnetworkops as nw

from copy import deepcopy
from argparse import Namespace

from anvio.dbops import ContigsDatabase
from anvio.errors import ConfigError, FilesNPathsError
from anvio.terminal import time_program

__copyright__ = "Copyleft 2015-2025, The Anvi'o Project (http://anvio.org/)"
__license__ = "GPL 3.0"
__version__ = anvio.__version__
__authors__ = ['ivagljiva']
__requires__ = ['contigs-db'] #TODO: add equivalent-compounds-txt as new artifact
__provides__ = []
__description__ = "Predicts metabolic exchanges between microbes based on the reaction network"

run = terminal.Run()
progress = terminal.Progress()

@time_program
def main(args):

    #input sanity checks
    if args.contigs_db_1 or args.contigs_db_2:
        if not args.contigs_db_2 or not args.contigs_db_1:
            raise ConfigError("You need two contigs databases for this to work.")
    if args.use_equivalent_amino_acids and args.custom_equivalent_compounds_file:
        raise ConfigError("You can only provide one of `--use-equivalent-amino-acids` and `--custom-equivalent-compounds-file`. If you "
                        "want to equate L- and non-stereo-specific amino acid IDs, you should include them in your custom equivalents file. "
                        "(Pro tip: the easiest way to do that is to run this program once with just `--use-equivalent-amino-acids` to get the "
                        "AA equivalents file, and modify from there)")

    eq_compounds = {}
    run.info("Using equivalent L- and non-stereo-specific amino acid compound IDs", args.use_equivalent_amino_acids)
    if args.use_equivalent_amino_acids:
        eq_compounds = find_equivalent_amino_acids(args)
    elif args.custom_equivalent_compounds_file:
        run.info("Custom equivalent compounds file", args.custom_equivalent_compounds_file)
        eq_compounds = utils.get_TAB_delimited_file_as_dictionary(args.custom_equivalent_compounds_file, expected_fields=['compound_id','equivalent_id'])
        # make sure each match is in there twice for easy lookups from either direction
        pairs_to_add = {}
        for c, match in eq_compounds.items():
            c2 = match['equivalent_id']
            if c2 not in eq_compounds:
                pairs_to_add[c2] = {'equivalent_id': c}
            elif eq_compounds[c2]['equivalent_id'] != c:
                raise ConfigError(f"While parsing your file of custom equivalent compound IDs, we found a pair of equivalents that don't match: "
                                    f"compound {c} is paired with {c2}, while {c2} is paired with {eq_compounds[c2]['equivalent_id']}. You should probably "
                                    f"fix that.")
        if pairs_to_add:
            eq_compounds.update(pairs_to_add)
            if anvio.DEBUG:
                run.warning(f"Found {len(pairs_to_add)} inverse pairs of equivalent compounds that were not in the equivalent compounds file. "
                                    f"These have been added to the dictionary of equivalent compounds. Here is the set of missing pairs: {pairs_to_add}. ",
                                    header="DEBUG", lc="yellow")
    
    run.info("Doing pathway walks for additional evidence", not args.no_pathway_walk)

    constructor = rn.Constructor()
    run.info("Loading reaction network from database", args.contigs_db_1)
    net_1 = constructor.load_network(contigs_db=args.contigs_db_1, quiet=True)
    run.info("Loading reaction network from database", args.contigs_db_2)
    net_2 = constructor.load_network(contigs_db=args.contigs_db_2, quiet=True)

    merged, db_names = net_1._merge_two_genome_networks(net_2)
    run.info_single(f"Created a merged network with {len(merged.genes)} genes.")

    reaction_to_pathways = merged._get_reaction_to_pathway_map_dict(map_ids_to_exclude=set(["00470"]), id_selection_prefix = "00")
    compound_to_pathways = {} # we will fill this dict in as we process each compound

    def get_reaction_equation(reaction_value):
        name_list = [merged.metabolites[c].modelseed_name for c in reaction_value.compound_ids]
        return rn.get_chemical_equation(reaction_value, use_compound_names=name_list, ignore_compartments = True)

    # dictionaries to store output
    potentially_exchanged_compounds = {}
    unique_compounds = {}
    pathway_walk_evidence = {}
    pathway_walk_dict_key = 0

     # loop over all metabolites
    num_compounds_to_process = len(merged.metabolites)
    processed_count=0
    progress.new('Processing compounds', progress_total_items=num_compounds_to_process)
    for compound_id in merged.metabolites:
        compound_name = merged.metabolites[compound_id].modelseed_name
        if anvio.DEBUG:
            progress.reset()
            run.info_single(f"Working on compound {compound_id} ({compound_name})")
        sub_ids = [compound_id]
        if compound_id in eq_compounds:
            sub_ids.append(eq_compounds[compound_id]['equivalent_id'])
        sub_network = merged.subset_network(metabolites_to_subset=sub_ids)

        genomes_produce = set([])
        genomes_consume = set([])
        production_reactions = {g: {} for g in db_names}
        consumption_reactions = {g: {} for g in db_names}
        compound_to_pathways[compound_id] = set([])
        for rid, reaction in sub_network.reactions.items():
            compound_to_pathways[compound_id].update(reaction_to_pathways[rid])

            # replace all equivalent IDs with the compound ID we are currently working on in the network
            # TODO: make this a function of the reaction network class?
            if compound_id in eq_compounds:
                reaction.compound_ids = [compound_id if x == eq_compounds[compound_id]['equivalent_id'] else x for x in reaction.compound_ids]

            idx = reaction.compound_ids.index(compound_id) 
            #TODO: make a dict of compounds with transport reactions and use as evidence in final output
            if reaction.compound_ids.count(compound_id) > 1: # likely a transport reaction, ignore
                if anvio.DEBUG:
                    run.warning(f"Found {compound_id} more than once in {rid}. We are skipping this reaction",
                                    header="DEBUG", lc="yellow")
                continue
            # which genomes produce this compound?
            elif reaction.coefficients[idx] > 0:
                for g in db_names:
                    if g in reaction.genomes_of_origin:
                        genomes_produce.add(g)
                        production_reactions[g][rid] = get_reaction_equation(reaction)

            # which genomes utilize this compound?
            elif reaction.coefficients[idx] < 0:
                for g in db_names:
                    if g in reaction.genomes_of_origin:
                        genomes_consume.add(g)
                        consumption_reactions[g][rid] = get_reaction_equation(reaction)
        
        def add_reactions_to_dict_for_compound(compound_dict):
            """Modifies the compound dictionary in place to add production and consumption reaction output"""
            for g in db_names:
                prod_rxn_ids = sorted(production_reactions[g].keys())
                cons_rxn_ids = sorted(consumption_reactions[g].keys())
                prod_rxn_eqs = [production_reactions[g][rid] for rid in prod_rxn_ids]
                cons_rxn_eqs = [consumption_reactions[g][rid] for rid in cons_rxn_ids]
                compound_dict[f"production_rxn_ids_{g}"] = " / ".join(prod_rxn_ids) if len(prod_rxn_ids) else None
                compound_dict[f"consumption_rxn_ids_{g}"] = " / ".join(cons_rxn_ids) if len(cons_rxn_ids) else None
                compound_dict[f"production_rxn_eqs_{g}"] = " / ".join(prod_rxn_eqs) if len(prod_rxn_eqs) else None
                compound_dict[f"consumption_rxn_eqs_{g}"] = " / ".join(cons_rxn_eqs) if len(cons_rxn_eqs) else None
            
        # potential interactions:
        # A: if one produces and other consumes
        # B: if one produces and both consume
        # C: if both produce and one consumes? seems less likely even though its the exact opposite of C
        if len(genomes_produce) == 1 or len(genomes_consume) == 1:
            # when the same genome produces and/or consumes, compound is unique to one genome
            if genomes_produce == genomes_consume:
                unique_compounds[compound_id] = {'compound_name': compound_name, 'genomes': list(genomes_produce)[0],
                                                    'produced_by': list(genomes_produce)[0], 
                                                    'consumed_by': list(genomes_consume)[0],
                                                }
                add_reactions_to_dict_for_compound(unique_compounds[compound_id])

            elif len(genomes_produce) == 0 or len(genomes_consume) == 0:
                unique_compounds[compound_id] = {'compound_name': compound_name, 'genomes': list(genomes_produce.union(genomes_consume))[0],
                                                    'produced_by': list(genomes_produce)[0] if len(genomes_produce) > 0 else None, 
                                                    'consumed_by': list(genomes_consume)[0] if len(genomes_consume) > 0 else None,
                                                }
                add_reactions_to_dict_for_compound(unique_compounds[compound_id])

            else: # A B or C applies
                potentially_exchanged_compounds[compound_id] = {'compound_name': compound_name, 
                                                                'genomes': ",".join(list(genomes_produce.union(genomes_consume))),
                                                                'produced_by': ",".join(genomes_produce),
                                                                'consumed_by': ",".join(genomes_consume),
                                                                }
                add_reactions_to_dict_for_compound(potentially_exchanged_compounds[compound_id])

                # look for additional evidence by walking through the reaction networks using Pathway Maps
                if not args.no_pathway_walk:
                    producer_network = net_1
                    producer_name = db_names[0]
                    consumer_network = net_2
                    consumer_name = db_names[1]
                    if db_names[0] not in genomes_produce or (db_names[0] in genomes_consume and len(genomes_consume) == 1):
                        producer_network = net_2
                        producer_name = db_names[1]
                        consumer_network = net_1
                        consumer_name = db_names[0]

                    overall_max_prior = None
                    overall_max_posterior = None
                    for map_id in compound_to_pathways[compound_id]:
                        max_prior_reactions = walk_pathway_map_for_compound(compound_id, map_id, producer_network, 'produce')
                        pathway_walk_evidence[pathway_walk_dict_key] = {'compound': compound_id,
                                                                        'type': "production",
                                                                        'organism': producer_name,
                                                                        'pathway_map': map_id,
                                                                        'longest_reaction_chain_length': max_prior_reactions}
                        pathway_walk_dict_key += 1
                        max_posterior_reactions= walk_pathway_map_for_compound(compound_id, map_id, consumer_network, 'consume')
                        pathway_walk_evidence[pathway_walk_dict_key] = {'compound': compound_id,
                                                                        'type': "consumption",
                                                                        'organism': consumer_name,
                                                                        'pathway_map': map_id,
                                                                        'longest_reaction_chain_length': max_posterior_reactions}
                        pathway_walk_dict_key += 1
                        if anvio.DEBUG:
                            progress.reset()
                            run.info_single(f"Walked through pathway map {map_id} for compound {compound_name} ({compound_id}); "
                                            f"found max of {max_prior_reactions} prior reactions in producer and {max_posterior_reactions} posterior reactions in consumer")
                        
                        # we want to find the longest chain of production reactions + the longest chain of consumption reactions
                        if (not overall_max_prior and max_prior_reactions) or \
                            (overall_max_prior and max_prior_reactions and overall_max_prior < max_prior_reactions):
                            overall_max_prior = max_prior_reactions
                        if (not overall_max_posterior and max_posterior_reactions) or \
                            (overall_max_posterior and max_posterior_reactions and overall_max_posterior < max_posterior_reactions):
                            overall_max_posterior = max_posterior_reactions

                    longest_overall_chain = None
                    if overall_max_prior and overall_max_posterior:
                        longest_overall_chain = overall_max_prior + overall_max_posterior
                    elif overall_max_prior:
                        longest_overall_chain = overall_max_prior
                    elif overall_max_posterior:
                        longest_overall_chain = overall_max_posterior
                    potentially_exchanged_compounds[compound_id]['max_reaction_chain_length'] = longest_overall_chain

        processed_count += 1
        progress.update(f"{processed_count} / {num_compounds_to_process} compounds processsed")
        progress.increment(increment_to=processed_count)
    
    progress.end()
    run.warning(f"Identified {len(potentially_exchanged_compounds)} potentially exchanged compounds and {len(unique_compounds)} compounds unique to one genome.", 
                header='RESULTS', lc='green')

    output_header = ['compound_id', 'compound_name', 'genomes', 'produced_by', 'consumed_by']
    if args.add_reactions_to_output:
        output_header += [f"production_rxn_ids_{g}" for g in db_names] + [f"consumption_rxn_ids_{g}" for g in db_names] + \
        [f"production_rxn_eqs_{g}" for g in db_names] + [f"consumption_rxn_eqs_{g}" for g in db_names]
    exchange_header = deepcopy(output_header)
    if not args.no_pathway_walk:
        exchange_header += ['max_reaction_chain_length']
    utils.store_dict_as_TAB_delimited_file(potentially_exchanged_compounds, f"{args.output_file_prefix}-potentially-exchanged-compounds.txt", 
                key_header='compound_id', none_value="None", headers=exchange_header)
    utils.store_dict_as_TAB_delimited_file(unique_compounds, f"{args.output_file_prefix}-unique-compounds.txt", 
                key_header='compound_id', none_value="None", headers=output_header)
    if not args.no_pathway_walk:
        utils.store_dict_as_TAB_delimited_file(pathway_walk_evidence, f"{args.output_file_prefix}-evidence.txt", 
                    do_not_write_key_column=True, none_value="None") 
    

def find_equivalent_amino_acids(args, run=run, progress=progress, print_to_file=True, output_file_name="equivalent_amino_acids.txt"):
    """Looks through the ModelSEED compound table to identify L-amino acids and their non-stereo-specific counterparts.
    
    Returns a dictionary in which keys are compound IDs matched to their names and the equivalent compound ID. Each match is 
    in the dictionary twice to enable O(1) lookups with either compound ID.

    Parameters
    ==========
    print_to_file : Boolean
        if True, the dictionary of equivalent compounds will be written to a tab-delimited output file
    output_file_name : string
        the name of the output file to print to (if desired)
    """

    MS_db = rn.ModelSEEDDatabase(modelseed_dir=args.modelseed_data_dir)
    comps = MS_db.compounds_table.dropna(subset="name")

    aa_list = anvio.constants.amino_acids_long + ["Selenocysteine", "Pyrrolysine"]
    equivalent_AAs = {}
    for a in aa_list:
        eqs = comps[(comps.name == a) | (comps.name == f"L-{a}")]['name']
        id_list = eqs.index.to_list()
        if not len(id_list) == 2:
            if anvio.DEBUG:
                compound_list = [f"{i} ({comps.loc[i]})" for i in id_list]
                run.warning(f"While looking for equivalent compound IDs for the amino acid {a}, we didn't find the "
                            f"expected 2 matching compounds '{a}' and 'L-{a}'. Instead, here is what we found: "
                            f"{', '.join(compound_list)}. No equivalencies will be stored for this amino acid.", header='DEBUG', lc='yellow')
            continue
        equivalent_AAs[id_list[0]] = {'equivalent_id': id_list[1], 'name': eqs.loc[id_list[0]], 'equivalent_name': eqs.loc[id_list[1]]}
        equivalent_AAs[id_list[1]] = {'equivalent_id': id_list[0], 'name': eqs.loc[id_list[1]], 'equivalent_name': eqs.loc[id_list[0]]}

    if print_to_file:
        utils.store_dict_as_TAB_delimited_file(equivalent_AAs, output_file_name, key_header='compound_id', 
                    headers = ['compound_id', 'equivalent_id', 'name', 'equivalent_name'])
        run.info("File of equivalent amino acid compound IDs", output_file_name)

    return equivalent_AAs

def get_args_for_pathway_walker(net, pathway_map, fate, gaps):
    """Returns a Namespace with arguments for KGMLNetworkWalker"""
    
    walker_args = Namespace()
    walker_args.network = net
    walker_args.kegg_pathway_number = pathway_map
    walker_args.compound_fate = fate
    walker_args.max_gaps = gaps
    walker_args.verbose = False
    return walker_args

def walk_pathway_map_for_compound(compound_id, pathway_map_id, organism, compound_fate='produce'):
    """Walks a KEGG Pathway Map to identify reactions leading to a compound in an organism.

    Returns the reaction chains of either, (1) prior reactions that 'produce' a compound OR 
    (2) posterior reactions that 'consume' a compound in the provided organism's reaction network.

    Parameters
    ==========
    compound_id : str
        The ModelSEED ID for the compound of interest
    pathway_map_id : str
        The KEGG Pathway Map to walk through. Should include this compound.
    organism : ReactionNetwork
        Loaded reaction network of the organism that can produce/consume this compound.
    compound_fate : str
        One of 'produce' or 'consume'. 'produce' is the default
    """

    try:
        wargs = get_args_for_pathway_walker(organism, pathway_map_id, compound_fate, args.maximum_gaps)
        walker = nw.KGMLNetworkWalker(wargs)
        reaction_chains = walker.get_chains(modelseed_compound_ids=compound_id)
        if not reaction_chains:
            return []
        return reaction_chains[compound_id]

    except ConfigError as c: # this is redundant for now, but useful for debugging
        print(f"Got ConfigError from pathway walker for {compound_id} in map {pathway_map_id}: {c}")
        return None
    except AssertionError as a:
        print(f"Got AssertionError from pathway walker for {compound_id} in map {pathway_map_id}: {a}")
        return None


if __name__ == '__main__':
    from anvio.argparse import ArgumentParser

    parser = ArgumentParser(description=__description__)

    groupA = parser.add_argument_group('INPUT', "Just give us contigs databases that already had reaction networks generated "
                                                        "for them via `anvi-reaction-network`, and we will do the rest.")
    groupA.add_argument('-c1', '--contigs-db-1', required=True, help="Contigs database (generated by `anvi-gen-contigs-database`) for your first genome")
    groupA.add_argument('-c2', '--contigs-db-2', required=True, help="Contigs database (generated by `anvi-gen-contigs-database`) for your second genome")

    groupB = parser.add_argument_group('OUTPUT', "How do you want to see the results?")
    groupB.add_argument(*anvio.A('output-file-prefix'), **anvio.K('output-file-prefix', {'required': True}))

    groupC = parser.add_argument_group('METABOLISM DATA LOCATION', "What metabolism database(s) do you want to use?")
    groupC.add_argument(*anvio.A('kegg-data-dir'), **anvio.K('kegg-data-dir'))
    groupC.add_argument(*anvio.A('modelseed-data-dir'), **anvio.K('modelseed-data-dir'))

    groupD = parser.add_argument_group('CUSTOMIZATION', "Decisions only you can make.")
    groupD.add_argument(*anvio.A('use-equivalent-amino-acids'), **anvio.K('use-equivalent-amino-acids'))
    groupD.add_argument(*anvio.A('custom-equivalent-compounds-file'), **anvio.K('custom-equivalent-compounds-file'))
    groupD.add_argument('--maximum-gaps', required=False, type=int, metavar="INT", default=0, help="We'll look for the longest chain of reactions surrounding "
                                                        "each potentially-exchanged metabolite to help rank the output by "
                                                        "likelihood of the interaction. This parameter allows you to choose "
                                                        "how many gaps there can be in the chain on either side of the metabolite "
                                                        "in the network. Very conservatively set to 0, as in no gaps allowed.")
    groupD.add_argument('--add-reactions-to-output', required=False, action='store_true', help="Do you want relevant reaction IDs and chemical "
                                                        "equations to be added to the output? Use this flag.")

    groupE = parser.add_argument_group('PERFORMANCE', "Because ain't nobody got time for that")
    groupE.add_argument(*anvio.A('num-threads'), **anvio.K('num-threads'))
    groupE.add_argument('--no-pathway-walk', required=False, action='store_true', help="Skip walking KEGG pathways in the network upstream and downstream of "
                                                            "predicted exchanges for additional evidence to rank predictions (a time-consuming step).")

    args = parser.get_args(parser)

    try:
        main(args)
    except ConfigError as e:
        print(e)
        sys.exit(-1)
    except FilesNPathsError as e:
        print(e)
        sys.exit(-1)