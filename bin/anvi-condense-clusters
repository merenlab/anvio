#!/usr/bin/env python
# -*- coding: utf-8

import anvio.db

import pysam
import argparse
import os
import re

from copy import deepcopy


def remap_queries(ref_name,
                  outf,
                  fasta,
                  orig_ref_name=None,
                  parent_mismatch_in_orig_ref_frame_list=None,
                  mismatch_in_orig_ref_frame_dict=None,
                  encountered_ref_names=None,
                  written_ref_names=None,
                  recursion_count=0,
                  ref_start_pos_in_orig_ref_frame=0):

    if recursion_count == 0:
        orig_ref_name = ref_name
        parent_mismatch_in_orig_ref_frame_list = []
        mismatch_in_orig_ref_frame_dict = {}
    if encountered_ref_names is None:
        encountered_ref_names = [ref_name]
    if written_ref_names is None:
        written_ref_names = []

    aligned_segments = bamfile.fetch(ref_name)
    for aligned_segment in aligned_segments:
        query_name = aligned_segment.query_name

        if query_name == ref_name: # a read can only map to itself once
            fasta.write(">%s\n" % query_name)
            fasta.write("%s\n" % aligned_segment.query_sequence)

            for replicate_name in replicate_name_dict[query_name][1:]: # first entry is query_name
                aligned_segment.query_name = replicate_name
                outf.write(aligned_segment)

        if query_name not in encountered_ref_names: # aggregate mappings to the query as part of the cluster:
            encountered_ref_names.append(query_name) # queries are subsequently investigated as refs

            num_mismatched_nucleotides = aligned_segment.get_tag('NM')
            if num_mismatched_nucleotides > 1: # multiple consecutive mismatched nucleotides count as 1 alignment mismatch
                remap_queries(query_name,
                              raw_outbamfile2,
                              condensed_seqs_fasta2,
                              encountered_ref_names=encountered_ref_names,
                              written_ref_names=written_ref_names) # these queries with multiple mismatches are treated as original ref seqs, forming a new cluster, but recorded separately from the other type of cluster
                continue

            mismatch_info_string = aligned_segment.get_tag('MD') # our alignments should have a matching region (ints) followed by a mismatching region of the nucleotides in the reference (chars) followed by a matching region (ints)
            mismatch_info_substrings = re.split('(\D+)', mismatch_info_string)
            if len(mismatch_info_substrings) != 3:
                # THE EXCEPTION I HAVE INVESTIGATED ENDED IN CCA AND ALIGNED IN THE MIDDLE OF A LONGER READ ** WITHOUT ANY MISMATCHES **
                # COULD THIS BE A tRNA READ FROM THE MIDDLE OF THE MOLECULE?
                print(query_name)
                print(ref_name)
                print(orig_ref_name)
                print(mismatch_info_string)
                print()
                continue
            alignment_length_before_mismatch_string = mismatch_info_substrings[0]
            alignment_length_before_mismatch = int(alignment_length_before_mismatch_string)
            mismatched_nucleotide_from_parent = mismatch_info_substrings[1]
            alignment_length_after_mismatch_string = mismatch_info_substrings[2]

            alignment_start_pos_in_orig_ref_frame = ref_start_pos_in_orig_ref_frame + aligned_segment.reference_start # the start of the alignment and the start of the query in the reference are the same because of end-to-end alignment in bowtie2
            mismatch_pos_in_orig_ref_frame = alignment_start_pos_in_orig_ref_frame + alignment_length_before_mismatch

            if mismatch_pos_in_orig_ref_frame in mismatch_in_orig_ref_frame_dict:
                nucleotide_in_orig_ref_at_mismatch_pos = mismatch_in_orig_ref_frame_dict[mismatch_pos_in_orig_ref_frame]
            else:
                nucleotide_in_orig_ref_at_mismatch_pos = mismatched_nucleotide_from_parent
                mismatch_in_orig_ref_frame_dict[mismatch_pos_in_orig_ref_frame] = mismatched_nucleotide_from_parent

            mismatch_in_orig_ref_frame_list = [(mismatch_pos_in_orig_ref_frame, nucleotide_in_orig_ref_at_mismatch_pos)]
            mismatch_in_present_ref_frame_list = [(alignment_length_before_mismatch, nucleotide_in_orig_ref_at_mismatch_pos)]
            for parent_mismatch_pos_in_orig_ref_frame, parent_mismatch_nucleotide in parent_mismatch_in_orig_ref_frame_list: # find all mismatches between the query and the orig ref
                if parent_mismatch_pos_in_orig_ref_frame == mismatch_pos_in_orig_ref_frame:
                    continue # the mismatch position in the present alignment was also in the previous alignment
                if parent_mismatch_pos_in_orig_ref_frame >= alignment_start_pos_in_orig_ref_frame:
                    mismatch_in_orig_ref_frame_list.append((parent_mismatch_pos_in_orig_ref_frame, parent_mismatch_nucleotide))
                    mismatch_in_present_ref_frame_list.append((parent_mismatch_pos_in_orig_ref_frame - alignment_start_pos_in_orig_ref_frame, parent_mismatch_nucleotide))

            remap_queries(query_name,
                          outf,
                          fasta,
                          orig_ref_name=orig_ref_name,
                          parent_mismatch_in_orig_ref_frame_list=deepcopy(mismatch_in_orig_ref_frame_list),
                          mismatch_in_orig_ref_frame_dict=mismatch_in_orig_ref_frame_dict,
                          encountered_ref_names=encountered_ref_names,
                          written_ref_names=written_ref_names,
                          recursion_count=recursion_count + 1,
                          ref_start_pos_in_orig_ref_frame=alignment_start_pos_in_orig_ref_frame)

            aligned_segment.reference_name = orig_ref_name
            aligned_segment.reference_start = alignment_start_pos_in_orig_ref_frame
            aligned_segment.set_tag('NM', len(mismatch_in_orig_ref_frame_list))
            aligned_segment.set_tag('XM', len(mismatch_in_orig_ref_frame_list))

            if len(mismatch_in_present_ref_frame_list) == 1:
                md_tag = alignment_length_before_mismatch_string + nucleotide_in_orig_ref_at_mismatch_pos + alignment_length_after_mismatch_string
            else:
                mismatch_in_present_ref_frame_list.sort(key=lambda t: t[0])
                prev_mismatch_pos_in_present_ref_frame = mismatch_in_present_ref_frame_list[0][0]
                if prev_mismatch_pos_in_present_ref_frame == 0:
                    md_tag = '0' + mismatch_in_present_ref_frame_list[0][1] # must start with number of preceding matches in alignment
                else:
                    md_tag = str(prev_mismatch_pos_in_present_ref_frame) + mismatch_in_present_ref_frame_list[0][1]
                for mismatch_pos_in_present_ref_frame, nucleotide_in_orig_ref in mismatch_in_present_ref_frame_list[1:]:
                    match_length = mismatch_pos_in_present_ref_frame - prev_mismatch_pos_in_present_ref_frame - 1
                    if match_length == 0:
                        md_tag += nucleotide_in_orig_ref
                    else:
                        md_tag += str(match_length) + nucleotide_in_orig_ref
                    prev_mismatch_pos_in_present_ref_frame = mismatch_pos_in_present_ref_frame
                md_tag += str(aligned_segment.query_length - prev_mismatch_pos_in_present_ref_frame - 1) # query length and alignment length should be identical due to end-to-end alignment in bowtie2 and high gap penalty
            aligned_segment.set_tag('MD', md_tag)

            fasta.write(">%s\n" % query_name)
            fasta.write("%s\n" % aligned_segment.query_sequence)

            for replicate_name in replicate_name_dict[query_name]:
                aligned_segment.query_name = replicate_name
                outf.write(aligned_segment)
            written_ref_names.append(query_name)

    if recursion_count == 0:
        return written_ref_names

if __name__ == '__main__':
    parser = argparse.ArgumentParser()
    parser.add_argument('bamfile')
    parser.add_argument('outbamfile')
    parser.add_argument('tRNAseqdb')
    # args = parser.parse_args()

    args = parser.parse_args(['/Users/sammiller/Documents/test4/s10_demethylase.bam',
                              '/Users/sammiller/Documents/test4/s10_demethylase_new.bam',
                              '/Users/sammiller/Documents/test4/s10_demethylase_TRNASEQ.db'])

    bamfile = pysam.AlignmentFile(args.bamfile, 'rb')
    raw_outbam_filepath = os.path.splitext(args.outbamfile)[0] + "_RAW.bam"
    raw_outbam2_filepath = os.path.splitext(args.outbamfile)[0] + "_2_RAW.bam"

    replicate_name_dict = {
        row[0]: row[1].split(',') for row
        in anvio.db.DB(args.tRNAseqdb, 1).get_all_rows_from_table('tRNA_sequences')}

    refs_with_multiple_mappings = [] # Multiple query sequences, including the sequence itself, mapped to this sequence.
    for ref_name in bamfile.references:
        if bamfile.count(ref_name) > 1:
            refs_with_multiple_mappings.append(ref_name)

    if os.path.exists(raw_outbam_filepath):
        os.remove(raw_outbam_filepath)
    raw_outbamfile = pysam.AlignmentFile(raw_outbam_filepath, 'wb', header=bamfile.header.as_dict())
    if os.path.exists(raw_outbam2_filepath):
        os.remove(raw_outbam2_filepath)
    raw_outbamfile2 = pysam.AlignmentFile(raw_outbam2_filepath, 'wb', header=bamfile.header.as_dict())

    condensed_seqs_filepath = os.path.splitext(args.outbamfile)[0] + '.fasta'
    condensed_seqs_fasta = open(condensed_seqs_filepath, 'w')
    condensed_seqs_filepath2 = os.path.splitext(args.outbamfile)[0] + '_2.fasta'
    condensed_seqs_fasta2 = open(condensed_seqs_filepath2, 'w')

    # TODO: SORT BY REPLICATE COUNT FROM tRNAseq_sequences_table_name???
    written_refs = []
    print(len(refs_with_multiple_mappings))
    for i, ref_name in enumerate(refs_with_multiple_mappings):
        if ref_name not in written_refs:
            written_refs.extend(remap_queries(ref_name, raw_outbamfile, condensed_seqs_fasta))
            if i % 1000 == 0:
                print(i)

    raw_outbamfile.close()
    raw_outbamfile2.close()

    condensed_seqs_fasta.close()
    condensed_seqs_fasta2.close()

    pysam.sort('-o', args.outbamfile, raw_outbam_filepath)
    pysam.index(args.outbamfile)
    os.remove(raw_outbam_filepath)

    outbam2_filepath = os.path.splitext(args.outbamfile)[0] + '_2.bam'
    pysam.sort('-o', outbam2_filepath, raw_outbam2_filepath)
    pysam.index(outbam2_filepath)
    os.remove(raw_outbam2_filepath)