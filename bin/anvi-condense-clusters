#!/usr/bin/env python
# -*- coding: utf-8

import anvio.db

import pysam
import argparse
import os

from copy import deepcopy


def remap_queries(ref_name, outf, fasta, orig_ref_name=None, mismatch_info=None, encountered_refs=None, written_refs=None, recursion_count=0, ref_position_offset=0):
    if recursion_count == 0:
        orig_ref_name = ref_name
        mismatch_info = []
    if encountered_refs is None:
        encountered_refs = [ref_name]
    if written_refs is None:
        written_refs = []

    aligned_segments = bamfile.fetch(ref_name)
    for aligned_segment in aligned_segments:
        query_name = aligned_segment.query_name

        if query_name == ref_name:
            fasta.write(">%s\n" % query_name)
            fasta.write("%s\n" % aligned_segment.query_sequence)
            for replicate_name in replicate_name_dict[query_name][1:]:
                aligned_segment.query_name = replicate_name
                outf.write(aligned_segment)

        if query_name not in encountered_refs:
            encountered_refs.append(query_name)

            num_mismatched_nucleotides = aligned_segment.get_tag('NM')
            if num_mismatched_nucleotides > 1:
                remap_queries(query_name, raw_outbamfile2, condensed_seqs_fasta2, encountered_refs=encountered_refs, written_refs=written_refs)
                continue

            if recursion_count > 0:
                for mismatch_list in mismatch_info:
                    mismatch_list[0] += aligned_segment.pos

            mismatch_info_string = aligned_segment.get_tag('MD')
            alignment_start_length_string = ''
            mismatched_ref_nucleotide = ''
            alignment_end_length_string = ''
            for i, char in enumerate(mismatch_info_string):
                try:
                    int(char)
                except ValueError:
                    mismatched_ref_nucleotide = char
                    alignment_end_length_string += mismatch_info_string[i + 1: ]
                    break
                alignment_start_length_string += char
            try:
                mismatch_info.append([int(alignment_start_length_string), mismatched_ref_nucleotide, int(alignment_end_length_string)])
            except ValueError:
                print(query_name)
                print(mismatch_info)
                print(mismatch_info_string)
                print(alignment_start_length_string)
                print(mismatched_ref_nucleotide)
                print(alignment_end_length_string)
                print()
                break
            remap_queries(query_name, outf, fasta, orig_ref_name=orig_ref_name, mismatch_info=deepcopy(mismatch_info), encountered_refs=encountered_refs, written_refs=written_refs, recursion_count=recursion_count + 1, ref_position_offset=ref_position_offset + aligned_segment.pos)

            aligned_segment.reference_name = orig_ref_name
            aligned_segment.pos = aligned_segment.pos + ref_position_offset
            aligned_segment.set_tag('NM', num_mismatched_nucleotides + recursion_count)
            aligned_segment.set_tag('XM', num_mismatched_nucleotides + recursion_count)

            # Different sequences in the cluster can contribute mismatches at the same position.
            # The relevant reference nucleotide is from the first record that occurs for the position,
            # as this is the nucleotide from the "original" seed sequence.
            # This record occurs in `mismatch_info` before other records at the same position.
            if len(mismatch_info) == 1:
                md_tag = str(mismatch_info[0][0]) + mismatch_info[0][1] + str(mismatch_info[0][2])
            else:
                mismatch_positions = []
                unique_mismatch_info = []
                for mismatch_list in mismatch_info:
                    if mismatch_list[0] not in mismatch_positions:
                        unique_mismatch_info.append(mismatch_list)
                        mismatch_positions.append(mismatch_list[0])

                # Create the MD tag for the optional alignment section.
                # Mismatches must be considered in order of occurrence in the alignment.
                unique_mismatch_info.sort(key=lambda mismatch_list: mismatch_list[0])
                md_tag = ''
                preceding_match_pos = 0
                for mismatch_list in unique_mismatch_info:
                    num_preceding_matches = mismatch_list[0] - preceding_match_pos
                    if num_preceding_matches == 0:
                        md_tag += mismatch_list[1]
                    else:
                        md_tag += str(num_preceding_matches) + mismatch_list[1]
                    preceding_match_pos = mismatch_list[0] + 1
                md_tag += str(unique_mismatch_info[-1][2])

            aligned_segment.set_tag('MD', md_tag)

            fasta.write(">%s\n" % query_name)
            fasta.write("%s\n" % aligned_segment.query_sequence)
            for replicate_name in replicate_name_dict[query_name]:
                aligned_segment.query_name = replicate_name
                outf.write(aligned_segment)
            written_refs.append(query_name)

    if recursion_count == 0:
        return written_refs

if __name__ == '__main__':
    parser = argparse.ArgumentParser()
    parser.add_argument('bamfile')
    parser.add_argument('outbamfile')
    parser.add_argument('tRNAseqdb')
    args = parser.parse_args()

    bamfile = pysam.AlignmentFile(args.bamfile, 'rb')
    raw_outbam_filepath = os.path.splitext(args.outbamfile)[0] + "_RAW.bam"
    raw_outbam2_filepath = os.path.splitext(args.outbamfile)[0] + "_2_RAW.bam"

    replicate_name_dict = {
        row[0]: row[1].split(',') for row
        in anvio.db.DB(args.tRNAseqdb, 1).get_all_rows_from_table('tRNA_sequences')}

    refs_with_multiple_mappings = [] # Multiple query sequences, including the sequence itself, mapped to this sequence.
    for ref_name in bamfile.references:
        if bamfile.count(ref_name) > 1:
            refs_with_multiple_mappings.append(ref_name)

    if os.path.exists(raw_outbam_filepath):
        os.remove(raw_outbam_filepath)
    raw_outbamfile = pysam.AlignmentFile(raw_outbam_filepath, 'wb', header=bamfile.header.as_dict())
    if os.path.exists(raw_outbam2_filepath):
        os.remove(raw_outbam2_filepath)
    raw_outbamfile2 = pysam.AlignmentFile(raw_outbam2_filepath, 'wb', header=bamfile.header.as_dict())

    condensed_seqs_filepath = os.path.splitext(args.outbamfile)[0] + '.fasta'
    condensed_seqs_fasta = open(condensed_seqs_filepath, 'w')
    condensed_seqs_filepath2 = os.path.splitext(args.outbamfile)[0] + '.fasta'
    condensed_seqs_fasta2 = open(condensed_seqs_filepath2, 'w')

    # TODO: SORT BY REPLICATE COUNT FROM tRNAseq_sequences_table_name???
    written_refs = []
    for ref_name in refs_with_multiple_mappings:
        if ref_name not in written_refs:
            written_refs.extend(remap_queries(ref_name, raw_outbamfile, condensed_seqs_fasta))

    raw_outbamfile.close()
    raw_outbamfile2.close()

    condensed_seqs_fasta.close()
    condensed_seqs_fasta2.close()

    pysam.sort('-o', args.outbamfile, raw_outbam_filepath)
    pysam.index(args.outbamfile)
    os.remove(raw_outbam_filepath)

    outbam2_filepath = os.path.splitext(args.outbamfile)[0] + '_2.bam'
    pysam.sort('-o', outbam2_filepath, raw_outbam2_filepath)
    pysam.index(outbam2_filepath)
    os.remove(raw_outbam2_filepath)