#!/usr/bin/env python
# -*- coding: utf-8

import os
import sys
import glob
import argparse
import textwrap
import numpy as np
import pandas as pd

from collections import OrderedDict
from tabulate import tabulate

import anvio
import anvio.utils as utils
import anvio.programs as p
import anvio.terminal as terminal
import anvio.filesnpaths as filesnpaths

from anvio.errors import ConfigError


__author__ = "Developers of anvi'o (see AUTHORS.txt)"
__copyright__ = "Copyleft 2015-2018, the Meren Lab (http://merenlab.org/)"
__credits__ = []
__license__ = "GPL 3.0"
__version__ = anvio.__version__
__maintainer__ = "Evan Kiefl"
__email__ = "kiefl.evan@gmail.com"
__description__ = "Search for anvi\'o programs by keyword, inputs/outputs, etc."


run = terminal.Run()
progress = terminal.Progress()

COL_WIDTH = 20
T = lambda x, l=COL_WIDTH: textwrap.TextWrapper(width=l, break_on_hyphens=True, break_long_words=True).fill(text=x)
F = lambda x, l=COL_WIDTH: textwrap.TextWrapper(width=l, break_on_hyphens=False, break_long_words=False).fill(text=x)

class Table:
    def __init__(self, args):
        A = lambda x, t: t(args.__dict__[x]) if x in args.__dict__ else None
        null = lambda x: x
        self.keyword_user_input = A('keyword', null)
        self.requires = A('requires', null)
        self.provides = A('provides', null)
        self.status = A('status', null)
        self.tags_user_input = A('tags', null)
        self.has_resources = A('has_resources', bool)
        self.report = A('report', null)

        self.headers_to_report = []
        self.headers = ['Program', 'Description', 'Tags', 'Provides', 'Requires', 'Resources', 'Status']
        self.table = pd.DataFrame([], columns = self.headers)

        anvio_programs = p.AnvioPrograms(args)
        anvio_programs.create_program_classes(okay_if_no_meta=True, quiet=True)
        self.programs = anvio_programs.programs

        self.handle_inputs()


    def get_headers_to_report(self):
        if self.headers_to_report:
            return

        self.headers_to_report = ['Program', 'Description', 'Resources']
        if self.tags:
            self.headers_to_report.append('Tags')
        elif self.provides:
            self.headers_to_report.append('Provides')
        elif self.requires:
            self.headers_to_report.append('Requires')
        elif self.status:
            self.headers_to_report.append('Status')


    def handle_inputs(self):
        if self.requires and self.requires not in p.ANVIO_ITEMS:
            run.warning('', header='POSSIBLE OPTIONS', lc='green', nl_after=0)
            for option in sorted(list(p.ANVIO_ITEMS.keys())):
                run.info_single(option, mc='green')
            raise ConfigError('%s isn\'t a valid option for --requires. Above are your options.' \
                                  % self.requires)

        if self.provides and self.provides not in p.ANVIO_ITEMS:
            run.warning('', header='POSSIBLE OPTIONS', lc='green', nl_after=0)
            for option in sorted(list(p.ANVIO_ITEMS.keys())):
                run.info_single(option, mc='green')
            raise ConfigError('%s isn\'t a valid option for --provides. Above are your options.' \
                                  % self.provides)

        self.tags = []
        if self.tags_user_input:
            self.tags = [x.strip() for x in self.tags_user_input.split(',')]

            all_tags = []
            for program in self.programs:
                all_tags.extend(program.meta_info['tags']['value'])
            all_tags = set(all_tags)

            for tag in self.tags:
                if tag not in all_tags:
                    raise ConfigError('%s isn\'t a valid option for --tags. Here are your options: %s' \
                                           % (tag, ', '.join(all_tags)))

        self.keywords = []
        if self.keyword_user_input:
            self.keywords = [x.strip() for x in self.keyword_user_input.split(',')]

        if self.report:
            self.headers_to_report = ['Program'] + self.report.split(',')
            for header in self.headers_to_report:
                if header not in self.headers:
                    raise ConfigError('%s isn\'t a valid option for --report. Here are your options (comma separate them): %s' \
                                           % (header, ', '.join(self.headers)))
        else:
            self.get_headers_to_report()


    def process(self):
        self.populate_table()
        self.filter_table()
        self.display_table()


    def parse_description_from_program_call(self, program):
        log_file = filesnpaths.get_temp_file_path()
        output = utils.run_command_STDIN('%s --help' % (program.program_path), log_file, '').split('\n')

        try:
            _, description, _, _ = p.parse_help_output(output)
        except Exception as e:
            return ''

        return description.replace('\n', '')


    def populate_table(self):
        for program in self.programs:
            tags = program.meta_info['tags']['value']
            status = program.meta_info['status']['value']
            provides = [item.id for item in program.meta_info['provides']['value']]
            requires = [item.id for item in program.meta_info['requires']['value']]
            resources = program.meta_info['resources']['value']
            description = program.meta_info['description']['value']

            if not len(description):
                # Yes, it can be learned from parse_description_from_program_call,
                # No, it is not worth waiting ~1s for.
                pass

            row_info = [program.name, description, tags, provides, requires, resources, status]
            row = dict(zip(self.headers, row_info))
            self.table = self.table.append(row, ignore_index = True)

        self.table.sort_values(by = 'Program').reset_index(inplace = True)


    def filter_table(self):
        J = lambda l, item: True if item in l else False

        # filter by keyword
        has_keyword = []
        for keyword in self.keywords:
            has_keyword.append(self.table['Program'].str.contains(keyword))
        if has_keyword:
            self.table = self.table[np.logical_or.reduce(np.array(has_keyword))]

        # filter by resources
        if self.has_resources:
            self.table = self.table[self.table['Resources'].astype(str) != '[]']

        # filter by tags
        has_tag = []
        for tag in self.tags:
            has_tag.append(self.table['Tags'].apply(J, args = (tag, )))
        if has_tag:
            self.table = self.table[np.logical_or.reduce(np.array(has_tag))]

        if self.provides:
            self.table = self.table.loc[self.table['Provides'].apply(J, args = (self.provides, )), :]

        if self.requires:
            self.table = self.table.loc[self.table['Requires'].apply(J, args = (self.requires, )), :]

        if self.status:
            self.table = self.table.loc[self.table['Status'].apply(J, args = (self.status, )), :]

        self.table = self.table[self.headers_to_report]


    def display_table(self):
        tabulated = tabulate(self.make_printable(self.table, COL_WIDTH),
                             headers='keys',
                             showindex=False,
                             tablefmt="fancy_grid")

        terminal_width, _ = terminal.get_terminal_size()
        table_width = len(tabulated.__str__().split('\n')[0])
        diff = terminal_width - table_width

        if diff < 0:
            run.warning("The above table is wider than your window, so it looks weird. Try making \
                         your window bigger, zooming out (press - while holding command), or \
                         specifying fewer columns to report with --report.")
        else:
            if 'Description' in self.table.columns:
                tabulated = tabulate(self.make_printable(self.table, COL_WIDTH + diff),
                                     headers='keys',
                                     showindex=False,
                                     tablefmt="fancy_grid")
        print(tabulated)


    def make_printable(self, table, description_width=None):
        printable_table = self.table.copy(deep = True)

        for idx, row in printable_table.iterrows():
            printable_table.loc[idx, :] = self.make_row_printable(row, description_width)

        return printable_table


    def make_row_printable(self, row, description_width=None):
        for header, info in row.iteritems():
            if header == 'Resources':
                resources = [T(resource[0] + ':') + '\n' + T(resource[1]) for resource in info]
                formatted_info = '\n\n'.join(resources)

            elif header == 'Program':
                formatted_info = F(info) # never linebreaks the program name

            elif header == 'Description':
                print(description_width)
                formatted_info = T(info, description_width) if description_width else T(info)

            elif type(info) == list:
                formatted_info = '\n\n'.join([T(str(item)) for item in info])

            elif type(info) == str:
                formatted_info = T(info)

            else:
                formatted_info = info

            row.loc[header] = formatted_info

        return row


if __name__ == '__main__':
    parser = argparse.ArgumentParser(description=__description__)
    parser.add_argument('--keyword', '-k', help='Find programs that contain this in their name. Multiple \
                                                 keywords can be specified by commas (no spaces) and all \
                                                 programs matching at least one keyword will be displayed.')
    parser.add_argument('--requires', '-r', help='List programs that have these inputs. If you don\'t know \
                                                  what to input, type a random word to be told a list \
                                                  of valid options.')
    parser.add_argument('--provides', '-p', help='List programs that have these outputs. If you don\'t know \
                                                  what to input, type a random word to be told a list \
                                                  of valid options.')
    parser.add_argument('--tags', '-t', help='List programs that have these tags. You can provide multiple by \
                                              separating them with commas, e.g. pangenomics,phylogenomics. If \
                                              you don\'t know what to input, type a random word to be told \
                                              a list of valid options.')
    parser.add_argument('--has-resources', action='store_true', help='List programs if they have learning resources \
                                                                      associated to them.')
    parser.add_argument('--status', '-s', help='List programs that have these statuses (useful for developers).')
    parser.add_argument('--report', '-R', help='Which information would you like to be in the report? By default, \
                                                you get Description. Valid choices are Description, Tags, Requires, Provides, \
                                                Status, and Resources. Add multiple of them with commas (no whitespace). \
                                                For example, if you wanted Description and Resources, you would put \
                                                here Description,Resources')

    args = anvio.get_args(parser)
    try:
        Table(args).process()
    except ConfigError as e:
        print(e)
        sys.exit()
