#!/usr/bin/env python
# -*- coding: utf-8

import re
import os
import sys
import argparse

from collections import Counter
from tabulate import tabulate

import anvio
import anvio.utils as utils
import anvio.hmmops as hmmops
import anvio.terminal as terminal
import anvio.filesnpaths as filesnpaths
import anvio.ccollections as ccollections
import anvio.hmmopswrapper as hmmopswrapper

from anvio.drivers.diamond import Diamond
from anvio.dbops import ContigsSuperclass
from anvio.errors import ConfigError, FilesNPathsError


__author__ = "Developers of anvi'o (see AUTHORS.txt)"
__copyright__ = "Copyleft 2015-2018, the Meren Lab (http://merenlab.org/)"
__credits__ = []
__license__ = "GPL 3.0"
__version__ = anvio.__version__
__maintainer__ = "A. Murat Eren"
__email__ = "a.murat.eren@gmail.com"
__requires__ = ['contigs-db', 'profile-db', 'external-genomes', 'internal-genomes', 'hmm-profile']
__provides__ = ['genes-fasta', 'concatenated-gene-alignment-fasta']


run = terminal.Run()
progress = terminal.Progress()

run_quiet = terminal.Run(verbose=False)
progress_quiet = terminal.Progress(verbose=False)


class SCGTaxonomy:
    def __init__(self, args, run=terminal.Run(), progress=terminal.Progress()):
        self.args = args
        self.run = run
        self.progress = progress

        A = lambda x: args.__dict__[x] if x in args.__dict__ else None
        self.taxonomy_file_path = A('taxonomy_file')
        self.taxonomy_database_path = A('taxonomy_database')

        self.initialized = False

        self.SCGs = ["Ribosomal_L1", "Ribosomal_L13", "Ribosomal_L16", "Ribosomal_L17",
                     "Ribosomal_L2", "Ribosomal_L20", "Ribosomal_L21p", "Ribosomal_L22",
                     "Ribosomal_L27A", "Ribosomal_L3", "Ribosomal_L4", "Ribosomal_L6",
                     "Ribosomal_L9_C", "Ribosomal_S11", "Ribosomal_S2", "Ribosomal_S20p",
                     "Ribosomal_S3_C", "Ribosomal_S6", "Ribosomal_S7", "Ribosomal_S9",
                     "ribosomal_L24"]

        self.taxonomic_levels_parser = {'d': 't_domain',
                                        'p': "t_phylum",
                                        'c': "t_class",
                                        'o': "t_order",
                                        'f': "t_family",
                                        'g': "t_genus",
                                        's': "t_species"}

        self.taxonomic_levels = ['t_domain', "t_phylum", "t_class", "t_order", "t_family", "t_genus", "t_species"]

        self.SCG_DB_PATH = lambda SCG: os.path.join(self.taxonomy_database_path, "%s.dmnd" % SCG)

        self.taxonomy_dict = {}

        self.sanity_check()


    def sanity_check(self):
        filesnpaths.is_file_exists(self.taxonomy_file_path)
        filesnpaths.is_file_exists(self.taxonomy_database_path)

        if not len(self.SCGs):
            raise ConfigError("This class can't be used with out a list of single-copy core genes.")

        if not len(self.SCGs) == len(set(self.SCGs)):
            raise ConfigError("Each member of the list of SCGs you wish to use with this class must\
                               be unique and yes, you guessed right. You have some repeated gene\
                               names.")

        SCGs_missing_databases = [SCG for SCG in self.SCGs if not filesnpaths.is_file_exists(self.SCG_DB_PATH(SCG))]
        if len(SCGs_missing_databases):
            raise ConfigError("Even though anvi'o found the directory for databases for taxonomy stuff,\
                               your setup seems to be missing %d databases required for everything to work\
                               with the current genes configuration of this class. Here are the list of\
                               genes for which we are missing databases: '%s'." % (', '.join(missing_databases)))


    def init(self):
        if self.initialized:
            return

        # initialize taxonomy dict. we should do this through a database in the long run.
        with open(self.taxonomy_file_path, 'r') as taxonomy_file:
            for accession, taxonomy_text in [l.strip('\n').split('\t') for l in taxonomy_file.readlines() if not l.startswith('#') and l]:
                # taxonomy_text kinda looks like this:
                #
                #    d__Bacteria;p__Proteobacteria;c__Gammaproteobacteria;o__Pseudomonadales;f__Moraxellaceae;g__Acinetobacter;s__Acinetobacter sp1
                #
                d = {}
                for token, taxon in [e.split('__', 1) for e in taxonomy_text.split(';')]:
                    if token in self.taxonomic_levels_parser:
                        d[self.taxonomic_levels_parser[token]] = taxon

                self.taxonomy_dict[accession] = d

        self.initialized = True


    def show_hits(self, bin_name, gene_name, hits):
        self.run.warning(None, header='%s / %s' % (bin_name, gene_name), lc="green")
        header = ['%id', 'bitscore', 'taxonomy']
        table = []

        for hit in hits:
            table.append([hit['pident'], hit['bitscore'], ' / '.join(self.taxonomy_dict[hit['accession']].values())])

        print(tabulate(table, headers=header, tablefmt="fancy_grid", numalign="right"))


    def get_hmm_sequences_dict_into_bins(self, hmm_sequences_dict):
        hmm_sequences_dict_per_bin = {}
        for entry_id in hmm_sequences_dict:
            entry = hmm_sequences_dict[entry_id]
            bin_name = entry['bin_id']

            if bin_name in hmm_sequences_dict_per_bin:
                hmm_sequences_dict_per_bin[bin_name][entry_id] = entry
            else:
                hmm_sequences_dict_per_bin[bin_name] = {entry_id: entry}

        return hmm_sequences_dict_per_bin


    def predict_from_SCGs_dict(self, hmm_sequences_dict):
        """Takes an HMMs dictionary, and yields predictions"""

        self.init()

        # split hmm_sequences_dict
        hmm_sequences_dict_per_bin = self.get_hmm_sequences_dict_into_bins(hmm_sequences_dict)

        for bin_name in hmm_sequences_dict_per_bin:
            hits_per_gene = {}

            self.run.info('Bin name', bin_name)
            self.run.info('Num SCGs', len(hmm_sequences_dict_per_bin[bin_name]))
            self.run.info('SCGs', ', '.join([e['gene_name'] for e in hmm_sequences_dict_per_bin[bin_name].values()]))

            for entry in hmm_sequences_dict_per_bin[bin_name].values():
                gene_name = entry['gene_name']
                hits = self.get_raw_blast_hits(entry)

                # replace accessions with taxonomy
                for hit in hits:
                    hit['taxonomy'] = self.taxonomy_dict[hit['accession']]

                hits_per_gene[gene_name] = hits

                if anvio.DEBUG:
                    self.show_hits(bin_name, gene_name, hits)

                #if anvio.DEBUG:
                    #tab recap score_by_entry like :
                    #self.show_hits(bin_name, gene_name, hits)
            score_by_entry, number_of_matching_genes = self.get_cumul_hit_per_gene(hits_per_gene)
            get_consensus_taxonomy=self.get_consensus_taxonomy(score_by_entry,\
             number_of_matching_genes,hits_per_gene[gene_name])


    def get_cumul_hit_per_gene(self,hits_per_gene):
        """add bitscore of eatch blast per query"""

        cumul_hit_per_gene={}

        matching_genes=[gene for gene in hits_per_gene if len(hits_per_gene[gene])]

        self.run.info('SCGs with match(s)', ', '.join(matching_genes))
        number_of_matching_genes=len(matching_genes)
        for matching_gene in matching_genes:

            for entry in hits_per_gene[matching_gene]:

                    if entry["accession"] not in cumul_hit_per_gene:
                        cumul_hit_per_gene[entry['accession']]=float(entry['bitscore'])
                    else:
                        cumul_hit_per_gene[entry['accession']]=\
                        float(cumul_hit_per_gene[entry['accession']])\
                        +float(entry['bitscore'])

        return cumul_hit_per_gene, number_of_matching_genes

    def get_consensus_taxonomy(self, score_by_entry, number_of_matching_genes,hits_per_gene):

        for query in  score_by_entry.keys():
            maxscore=(max(score_by_entry.values()))/number_of_matching_genes
            # temporary
            taxo1=""
            taxo2=""
            for code, score in sorted(score_by_entry.items(), key=lambda x: (-x[1], x[0])):

                #add option of %
                if (float(score)/number_of_matching_genes)<(float(maxscore)*0.70):

                    break

                else:

                    print (code, (score/number_of_matching_genes))
                    if taxo1=="":
                        taxo1=self.taxonomy_dict[code]
                    else:
                        taxo2=self.taxonomy_dict[code]
                        #return list ........ creat db for taxonomy
                        taxo1=set(taxo1.values()).intersection(set(taxo2.values()))
            else:
                if taxo1=="":
                    taxo1="N/A"
                    break
                else:
                    break
            print(str(query)+"\t"+str(taxo1))


    def get_raw_blast_hits(self, d, max_target_seqs=20, evalue=1e-05, min_pct_id=50):
        """Takes a dictionary that contains `gene_name` and `sequence`, and returns
           filtered BLAST hits against the corresopnding database. I.e.,

            >>> d = {'sequence': 'MVRVKKGVNALKTRRNILKQAKGFRGPRKSKEKLAYEQLVHSYTSAFAHRRDKKGDFRRLWNVRINAALRPLGHTYSKFIGAMNKKGMEVDRKTLSDLAQNAPESFERLVKQVTA',
                     'gene_name': 'Ribosomal_L20'}
            >>> self.get_raw_blast_hits(d)
        """

        if 'sequence' not in d or 'gene_name' not in d:
            raise ConfigError("The `get_filtered_dict` function got a parameter that\
                               does not look like the way we expected it. This function\
                               expects a dictionary that contains keys `gene_name` and `sequence`.")

        db_path = self.SCG_DB_PATH(d['gene_name'])
        sequence = d['sequence']

        diamond = Diamond(db_path, run=run_quiet, progress=progress_quiet)
        diamond.max_target_seqs = max_target_seqs
        diamond.evalue = evalue
        diamond.min_pct_id = min_pct_id

        diamond_output = diamond.blastp_stdin(sequence)

        hits = []
        for entry in [line.split('\t') for line in diamond_output.split('\n') if line.startswith('seq')]:
            accession = entry[1]

            # dict(zip(['accession', 'pident', 'length', 'mismatch', 'gaps', 'qstart', 'qend', 'sstart', 'send', 'evalue', 'bitscore'], [float(entry[i]) if i > 1 else entry[i] for i in range(1, 12)]))
            hit = dict(zip(['accession', 'pident', 'bitscore'], [float(entry[i]) if i > 1 else entry[i] for i in [1, 2, 11]]))

            hits.append(hit)

        return hits


def main(args):
    if args.external_genomes and (args.contigs_db or args.profile_db):
        raise ConfigError("If you are interested in using a list of external genomes, you shouldn't be using a contigs db or\
                           profile db prameters.")

    if not (args.internal_genomes or args.external_genomes or args.contigs_db or args.profile_db):
        raise ConfigError("You gotta give this program some input files :/ Come on.")

    if args.concatenate_genes:
        if not args.return_best_hit:
            raise ConfigError("If you want your genes to be concatenated into a multi-alignment file, you must also ask for\
                               the best hit (using the `--return-best-hit`) flag to avoid issues if there are more than one\
                               hit for a gene in a given genome. Anvi'o could have set this flag on your behalf, but it just\
                               is not that kind of a platform :/")

    if args.concatenate_genes:
        # test whether we know about the aligner early on
        from anvio.drivers import Aligners
        Aligners().select(args.align_with)

    if args.max_num_genes_missing_from_bin and not args.gene_names and not args.list_available_gene_names:
        raise ConfigError("You can only use --max-num-genes-missing-from-bin flag if you already know what gene names you are\
                           interested in (just to make sure you know what you are doing).")

    for param, value in [('--max-num-genes-missing-from-bin', args.max_num_genes_missing_from_bin),
                         ('--min-num-bins-gene-occurs', args.min_num_bins_gene_occurs)]:
        if value is not None:
            try:
                value = int(value)
                assert(value >= 0)
            except:
                raise ConfigError("For obvious reasons, anvi'o expects the parameter %s to be a non-negative integer :/" % param)

    hmm_sources = set([s.strip() for s in args.hmm_sources.split(',')]) if args.hmm_sources else set([])

    if not len(hmm_sources):
        hmm_sources = set(["Bacteria_71"])

    if not args.gene_names:
        args.gene_names = "Ribosomal_L1,Ribosomal_L13,Ribosomal_L16,Ribosomal_L17,Ribosomal_L2,Ribosomal_L20,Ribosomal_L21p,Ribosomal_L22,Ribosomal_L27A,Ribosomal_L3,Ribosomal_L4,Ribosomal_L6,Ribosomal_L9_C,Ribosomal_S11,Ribosomal_S2,Ribosomal_S20p,Ribosomal_S3_C,Ribosomal_S6,Ribosomal_S7,Ribosomal_S9,ribosomal_L24"

    # the following if/else block either uses SequencesForHMMHits or the wrapper class
    # SequencesForHMMHitsWrapperForMultipleContigs (if there are multiple contigs files)
    # to get sequences, and construct `splits_dict` depending on the input files. it is
    # shitty code, and can be improved.
    if args.external_genomes or args.internal_genomes:
        s = hmmopswrapper.SequencesForHMMHitsWrapperForMultipleContigs(args, hmm_sources)
        splits_dict = s.splits_dict
    else:
        info_table = hmmops.SequencesForHMMHits(args.contigs_db).hmm_hits_info

        # let's quickly check whether we have all the hmm_sources the user may have
        # requested has anything to do with the ones we have in the database
        if hmm_sources:
            missing_hmm_sources = [s for s in hmm_sources if s not in info_table]
            if(missing_hmm_sources):
                raise ConfigError("At least one of the HMM sources you requested are missing form the HMMs the contigs database\
                                   knows about :/ Here they are: '%s'" % (', '.join(missing_hmm_sources)))

        if args.list_hmm_sources:
            hmmops.SequencesForHMMHits(args.contigs_db).list_available_hmm_sources()

        if args.list_available_gene_names:
            hmmops.SequencesForHMMHits(args.contigs_db).list_available_gene_names(sources=list(hmm_sources))

        if (args.profile_db and not args.collection_name) or (args.collection_name and not args.profile_db):
            raise ConfigError("You can't use this program with a profile database but without a collection name,\
                               and vice versa, you also can't use a collection if you didn't provide a profile database. Yes. Because.")

        if args.profile_db:
            utils.is_profile_db_and_contigs_db_compatible(args.profile_db, args.contigs_db)
            splits_dict = ccollections.GetSplitNamesInBins(args).get_dict()
            run.info('Init', '%d splits in %d bin(s)' % (sum([len(v) for v in list(splits_dict.values())]), len(splits_dict)))
        else:
            contigs_db = ContigsSuperclass(args, r = run, p = progress)
            contigs_db_name = os.path.basename(args.contigs_db[:-3])
            splits_dict = {contigs_db_name: list(contigs_db.splits_basic_info.keys())}

        s = hmmops.SequencesForHMMHits(args.contigs_db, sources = hmm_sources)

    CHK = lambda: exec('raise ConfigError("Your selections returned an empty list of genes to work with :/")') if not len(hmm_sequences_dict) else None

    hmm_sequences_dict = s.get_sequences_dict_for_hmm_hits_in_splits(splits_dict, return_amino_acid_sequences=args.get_aa_sequences)
    CHK()

    run.info('Hits', '%d hits for %d source(s)' % (len(hmm_sequences_dict), len(s.sources)))

    # figure out gene names.. if the user provided a file, use that, otherwhise parse gene names out of the comma-separated text
    if args.gene_names and filesnpaths.is_file_exists(args.gene_names, dont_raise=True):
        gene_names = [g.strip() for g in open(args.gene_names, 'rU').readlines()] if args.gene_names else []
    else:
        gene_names = [g.strip() for g in args.gene_names.split(',')] if args.gene_names else []

    if len(gene_names):
        hmm_sequences_dict = utils.get_filtered_dict(hmm_sequences_dict, 'gene_name', set(gene_names))
        run.info('Filtered hits', '%d hits remain after filtering for %d gene(s)' % (len(hmm_sequences_dict), len(gene_names)))
        CHK()

    if args.max_num_genes_missing_from_bin is not None:
        hmm_sequences_dict, bins_removed = s.filter_hmm_sequences_dict_for_bins_that_lack_more_than_N_genes(hmm_sequences_dict, gene_names, int(args.max_num_genes_missing_from_bin))
        CHK()

        if len(bins_removed):
            run.info('Filtered hits', '%d hits remain after filtering for `--max-num-genes-missing-from-bin` flag' % (len(hmm_sequences_dict)))

            run.warning('The `--max-num-genes-missing-from-bin` flag caused the removal of %d bins (or genomes, whatever)\
                         from your analysis. This is the list of bins that will live in our memories: %s' % \
                                                (len(bins_removed), ', '.join(bins_removed)))

    if args.min_num_bins_gene_occurs is not None:
        hmm_sequences_dict, genes_removed = s.filter_hmm_sequences_dict_from_genes_that_occur_in_less_than_N_bins(hmm_sequences_dict, int(args.min_num_bins_gene_occurs))
        CHK()

        if len(genes_removed):
            run.info('Filtered hits', '%d hits remain after filtering for `--min-num-bins-gene-occurs` flag' % (len(hmm_sequences_dict)))

            run.warning("The `--min-num-bins-gene-occurs` parameter caused the removal of %d genes from your analysis because \
                         they occurred in less than %d bins/genomes in your analysis. This is the list of genes that gon'\
                         buhbye: %s." % (len(genes_removed), int(args.min_num_bins_gene_occurs), ', '.join(genes_removed)))

            # update the gene names variable .. this is such a mess :( "WHO WROTE THIS SHIT CODE", yelled Meren, looking
            # at this cursed main function in his office on a Saturday night, knowing very well who did it. thanks
            # to his lack of shame he said to himself "well, I guess it is OK if it stays like this for now".
            if(gene_names):
                gene_names = [g for g in gene_names if g not in genes_removed]

    if args.return_best_hit:
        run.warning("You requested only the best hits to be reported, which means, if, say, there are more than one RecA\
                     hits in a bin for a given HMM source, only the one with the lowest e-value will be kept, and others\
                     will be removed from your final results.")

        if not args.profile_db:
            run.warning("You requested to get only the best hits, but you did not provide a profile database. At this point\
                         anvi'o just hopes you know what you are doing. Since this is like the zone of 'potentially a terrible\
                         idea but it may be quite relevant when done right'.")

        hmm_sequences_dict = s.filter_hmm_sequences_dict_for_splits_to_keep_only_best_hits(hmm_sequences_dict)
        CHK()

        run.info('Filtered hits', '%d hits remain after removing weak hits for multiple hits' % (len(hmm_sequences_dict)))

    t = SCGTaxonomy(args)
    t.predict_from_SCGs_dict(hmm_sequences_dict)


if __name__ == '__main__':
    parser = argparse.ArgumentParser(description="Get sequences for HMM hits from many inputs.")

    groupA = parser.add_argument_group('INPUT OPTION #1: CONTIGS DB', "There are multiple ways to access to sequences. Your first option is to\
                                        provide a contigs database, and call it a day. In this case the program will return you\
                                        everything from it.")
    groupA.add_argument(*anvio.A('contigs-db'), **anvio.K('contigs-db', {'required': False}))

    groupB = parser.add_argument_group('INPUT OPTION #2: CONTIGS DB + PROFLIE DB', "You can also work with anvi'o profile databases and collections\
                                        stored in them. If you go this way, you still will need to provide a contigs database. If you\
                                        just specify a collection name, you will get hits from every bin in it. You can also use\
                                        the bin name or bin ids file parameters to specify your interest more precisely.")
    groupB.add_argument(*anvio.A('profile-db'), **anvio.K('profile-db', {'required': False}))
    groupB.add_argument(*anvio.A('collection-name'), **anvio.K('collection-name'))
    groupB.add_argument(*anvio.A('bin-id'), **anvio.K('bin-id'))
    groupB.add_argument(*anvio.A('bin-ids-file'), **anvio.K('bin-ids-file'))

    groupC = parser.add_argument_group('INPUT OPTION #3: INT/EXTERNAL GENOMES FILE', "Yes. You can alternatively use as input an internal or external\
                                        genomes file, or both of them together. If you have multiple contigs databases without any profile\
                                        database, you can use the external genomes file. So if you just have a bunch of FASTA files and nothing else,\
                                        this is what you need. In contrast, if you want to access to genes in bins described in collections\
                                        stored in anvi'o profile databases, then you can use internal genomes file route. Or you can mix the two,\
                                        because why not. There is not much room for excuses here.")
    groupC.add_argument(*anvio.A('external-genomes'), **anvio.K('external-genomes'))
    groupC.add_argument(*anvio.A('internal-genomes'), **anvio.K('internal-genomes'))

    groupD = parser.add_argument_group('HMM STUFF', "This is where you can specify an HMM source, and/or a list of genes to filter\
                                        your results.")
    groupD.add_argument(*anvio.A('hmm-sources'), **anvio.K('hmm-sources'))
    groupD.add_argument(*anvio.A('gene-names'), **anvio.K('gene-names'))
    groupD.add_argument(*anvio.A('list-hmm-sources'), **anvio.K('list-hmm-sources'))
    groupD.add_argument(*anvio.A('list-available-gene-names'), **anvio.K('list-available-gene-names'))

    groupE = parser.add_argument_group('THE OUTPUT', "Where should the output go. It will be a FASTA file, and you better give it\
                                        a nice name..")
    groupE.add_argument(*anvio.A('output-file'), **anvio.K('output-file'))
    groupE.add_argument(*anvio.A('no-wrap'), **anvio.K('no-wrap'))

    groupF = parser.add_argument_group('THE ALPHABET', "The sequences are reported in DNA alphabet, but you can also get them\
                                        translated just like all the other cool kids.")
    groupF.add_argument(*anvio.A('get-aa-sequences'), **anvio.K('get-aa-sequences', {'default': True}))

    groupG = parser.add_argument_group('PHYLOGENOMICS? K!', "If you want, you can get your sequences concatanated. In this case\
                                       anwi'o will use muscle to align every homolog, and concatenate them the order you specified\
                                       using the `gene-names` argument. Each concatenated sequence will be separated from the other\
                                       ones by the `separator`.")
    groupG.add_argument(*anvio.A('concatenate-genes'), **anvio.K('concatenate-genes'))
    groupG.add_argument(*anvio.A('max-num-genes-missing-from-bin'), **anvio.K('max-num-genes-missing-from-bin'))
    groupG.add_argument(*anvio.A('min-num-bins-gene-occurs'), **anvio.K('min-num-bins-gene-occurs'))
    groupG.add_argument(*anvio.A('align-with'), **anvio.K('align-with'))
    groupG.add_argument(*anvio.A('separator'), **anvio.K('separator', {'help': 'A word that will be used to\
                                  sepaate concatenated gene sequences from each other (IF you are using this\
                                  program with `--concatenate-genes` flag). The default is "XXX" for amino\
                                  acid sequences, and "NNN" for DNA sequences'}))

    groupG = parser.add_argument_group('OPTIONAL', "Everything is optional, but some options are more optional than others.")
    groupG.add_argument(*anvio.A('return-best-hit'), **anvio.K('return-best-hit', {'default': True}))

    parser.add_argument("-t", "--taxonomy-file", help="taxo file", nargs='?')

    parser.add_argument("-r", "--taxonomy-database", help="db ribosomal prot", nargs='?')

    args = anvio.get_args(parser)

    try:
        main(args)
    except ConfigError as e:
        print(e)
        sys.exit(-1)
    except FilesNPathsError as e:
        print(e)
        sys.exit(-1)
