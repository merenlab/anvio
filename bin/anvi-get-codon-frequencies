#!/usr/bin/env python
# -*- coding: utf-8
"""Get codon or amino acid frequency statistics from genomes, genes, and functions."""

import sys
import argparse
import pandas as pd

import anvio
import anvio.terminal as terminal
import anvio.constants as constants
import anvio.codonusage as codonusage
import anvio.filesnpaths as filesnpaths

from anvio import FORCE_OVERWRITE
from anvio.argparse import ArgumentParser
from anvio.errors import ConfigError, FilesNPathsError


__copyright__ = "Copyleft 2015-2024, The Anvi'o Project (http://anvio.org/)"
__credits__ = []
__license__ = "GPL 3.0"
__version__ = anvio.__version__
__authors__ = ['semiller10', 'meren']
__requires__ = [
    'contigs-db',
    'profile-db',
    'collection',
    'bin',
    'internal-genomes',
    'external-genomes'
]
__provides__ = ['codon-frequencies-txt', 'aa-frequencies-txt']
__description__ = (
    "Get codon or amino acid frequency statistics from genomes, genes, and functions")


run = terminal.Run()


def main(args: argparse.Namespace) -> None:
    """
    Prepare arguments and get codon frequencies.

    Parameters
    ==========
    args : argparse.Namespace
        Parsed command line arguments.
    """
    # Synonymous frequencies are always relative to the other codons for the amino acid.
    if args.synonymous and not args.relative:
        args.relative = True

    # Determine whether output is per-gene or per-function. A generic output file is always assumed
    # to be a per-gene table.
    if (
        bool(args.output_file) +
        bool(args.gene_table_output) +
        bool(args.function_table_output)
    ) != 1:
        raise ConfigError(
            "One and only one of `--output-file`, `--gene-table-output`, or "
            "`--function-table-output` must be provided."
        )
    args.return_functions = bool(args.function_table_output)

    if args.output_file:
        args.gene_table_output = args.output_file

    # Check the validity of the output path.
    if args.gene_table_output:
        filesnpaths.is_output_file_writable(args.gene_table_output, ok_if_exists=FORCE_OVERWRITE)
    if args.function_table_output:
        filesnpaths.is_output_file_writable(
            args.function_table_output, ok_if_exists=FORCE_OVERWRITE
        )

    # Select function sources and functions of interest. All function sources can be selected with a
    # flag, or select sources can be provided as a list argument.
    if (
        (args.function_accessions or args.function_names) and
        (args.function_sources is None or len(args.function_sources) != 1)
    ):
        raise ConfigError(
            "`--function-accessions` and `--function-names` require a single value for "
            "`--function-sources`. If select functions come from more than one source, use "
            "`--select-functions-txt`."
        )

    if args.function_sources is None:
        if args.select_functions_txt is None:
            select_function_sources = None
        else:
            select_function_sources = []
    elif len(args.function_sources) == 0:
        select_function_sources = []
    else:
        select_function_sources = args.function_sources

    args.function_accessions_dict = {}
    if args.function_accessions:
        function_source = args.function_sources[0]
        for function_accession in args.function_accessions:
            try:
                args.function_accessions_dict[function_source].append(function_accession)
            except KeyError:
                args.function_accessions_dict[function_source] = [function_accession]

    args.function_names_dict = {}
    if args.function_names:
        function_source = args.function_sources[0]
        for function_name in args.function_names:
            try:
                args.function_names_dict[function_source].append(function_name)
            except KeyError:
                args.function_names_dict[function_source] = [function_name]

    if args.select_functions_txt:
        parse_select_functions_table(args, select_function_sources)

    args.function_sources = select_function_sources

    if not args.function_accessions_dict and not args.function_names_dict:
        # Specific functions cannot be expected when none were selected.
        args.expect_functions = False

    if args.function_table_output and not args.function_sources:
        raise ConfigError(
            "Function table output is expected, but no function sources were specified. "
            "`--function-table-output` must be used with `--function-sources` or "
            "`--select-functions-txt`."
        )

    # Check aggregate statistic options. Sum cannot be used with function sources. Average and
    # standard deviation can only be calculated for relative frequencies among genes of a function.
    if args.sum + args.average + args.standard_deviation > 1:
        raise ConfigError(
            "Only one aggregate statistics can be calculated at a time. `--sum`, `--average`, "
            "and `--standard-deviation` are mutually exclusive."
        )

    if args.sum and args.function_sources:
        raise ConfigError(
            "`--sum` cannot be used with `--function-sources` or `--select-functions-txt`, as "
            "frequencies are summed across genes in a genome, irrespective of function groups. "
            "Codon frequencies are summed across genes in each function with "
            "`--function-table-output`, by definition."
        )

    if (args.average or args.standard_deviation) and not (
        args.relative and args.function_table_output
    ):
        raise ConfigError(
            "`--average` and `--standard-deviation` must be used with `--relative` or "
            "`--synonymous` and `--function-table-output`. These aggregate statistics are "
            "calculated among genes that share a functional annotation. They are only allowed to "
            "operate on relative frequencies so that genes are normalized for length."
        )

    # Determine codons to explicitly exclude from the analysis. Codons to exclude are the complement
    # of codons to include.
    if args.include_codons and args.exclude_codons:
        raise ConfigError(
            "Either `--include-codons` or `--exclude-codons` should be given, not both."
        )

    if args.include_codons:
        args.exclude_codons = []
        for codon in constants.codons:
            if codon in args.include_codons:
                continue
            else:
                args.exclude_codons.append(codon)

    # Determine codons to explicitly not report in the output table. Codons to not report are the
    # complement of codons to report.
    if args.report_codons and args.dont_report_codons:
        raise ConfigError(
            "Either `--report-codons` or `--dont-report-codons` should be given, not both."
        )

    if args.report_codons:
        args.dont_report_codons = []
        for codon in constants.codons:
            if codon in args.report_codons:
                continue
            else:
                args.dont_report_codons.append(codon)

    # Determine amino acids (their codons) to exclude from the analysis. Amino acids to exclude are
    # the complement of amino acids to include.
    if args.include_amino_acids and args.exclude_amino_acids:
        raise ConfigError(
            "Either `--include-amino-acids` or `--exclude-amino-acids` should be given, not both."
        )

    if args.include_amino_acids:
        args.exclude_amino_acids = []
        for amino_acid in constants.amino_acids:
            if amino_acid in args.include_amino_acids:
                continue
            else:
                args.exclude_amino_acids.append(amino_acid)

    # Determine amino acids (or their codons) to not report in the output table. Amino acids to not
    # report are the complement of amino acids to report.
    if args.report_amino_acids and args.dont_report_amino_acids:
        raise ConfigError(
            "Either `--report-amino-acids` or `--dont-report-amino-acids` should be given, not "
            "both."
        )

    if args.report_amino_acids:
        args.dont_report_amino_acids = []
        for amino_acid in constants.amino_acids:
            if amino_acid in args.report_amino_acids:
                continue
            else:
                args.dont_report_amino_acids.append(amino_acid)

    if args.report_amino_acids and args.label_amino_acids:
        # Codons are not reported explicitly, so codon headers cannot be labeled with amino acids.
        args.label_amino_acids = False

    # Configure pansequence parameters.
    args.pansequence_min_codons = [
        int(args.pansequence_min_codons[0]), float(args.pansequence_min_codons[1])
    ]
    args.pansequence_min_amino_acids = [
        int(args.pansequence_min_amino_acids[0]), float(args.pansequence_min_amino_acids[1])
    ]

    # Get gene frequency tables.
    if args.internal_genomes or args.external_genomes:
        pass
    else:
        single_genome_codon_usage = codonusage.SingleGenomeCodonUsage(args, run=run)
        frequency_df = single_genome_codon_usage.statistics.get_frequencies()

    # # Get gene frequency tables.
    # if args.internal_genomes or args.external_genomes:
    #     multigenome_codon_usage = codonusage.MultiGenomeCodonUsage(args, run=run)
    #     frequency_df = multigenome_codon_usage.get_frequencies(
    #         from_function_sources=from_function_sources,
    #         return_functions=args.return_functions,
    #         return_amino_acids=args.return_amino_acids,
    #         function_accessions=args.function_accessions_dict,
    #         function_names=args.function_names_dict,
    #         expect_functions=args.expect_functions,
    #         relative=args.relative,
    #         synonymous=args.synonymous,
    #         sum_genes=args.sum,
    #         average_genes=args.average,
    #         gene_min_codons=args.gene_min_codons,
    #         function_min_codons=args.function_min_codons,
    #         min_codon_filter=args.min_codon_filter,
    #         drop_codons=args.exclude_codons,
    #         unreported_codons=args.dont_report_codons,
    #         drop_amino_acids=args.exclude_amino_acids,
    #         unreported_amino_acids=args.dont_report_amino_acids,
    #         sequence_min_codons=args.sequence_min_codons,
    #         pansequence_min_codons=args.pansequence_min_codons,
    #         sequence_min_amino_acids=args.sequence_min_amino_acids,
    #         pansequence_min_amino_acids=args.pansequence_min_amino_acids,
    #         label_amino_acids=args.header_amino_acids,
    #         infinity_to_zero=args.infinity_to_zero)
    # else:
    #     single_genome_codon_usage = codonusage.SingleGenomeCodonUsage(args, run=run)
    #     frequency_df = single_genome_codon_usage.get_frequencies(
    #         from_function_sources=from_function_sources,
    #         return_functions=args.return_functions,
    #         return_amino_acids=args.return_amino_acids,
    #         gene_caller_ids=args.gene_caller_ids,
    #         function_accessions=args.function_accessions_dict,
    #         function_names=args.function_names_dict,
    #         expect_functions=args.expect_functions,
    #         relative=args.relative,
    #         synonymous=args.synonymous,
    #         sum_genes=args.sum,
    #         average_genes=args.average,
    #         gene_min_codons=args.gene_min_codons,
    #         function_min_codons=args.function_min_codons,
    #         min_codon_filter=args.min_codon_filter,
    #         drop_codons=args.exclude_codons,
    #         unreported_codons=args.dont_report_codons,
    #         drop_amino_acids=args.exclude_amino_acids,
    #         unreported_amino_acids=args.dont_report_amino_acids,
    #         sequence_min_amino_acids=args.sequence_min_amino_acids,
    #         pansequence_min_amino_acids=args.pansequence_min_amino_acids,
    #         label_amino_acids=args.header_amino_acids,
    #         infinity_to_zero=args.infinity_to_zero)

    # Write output tables.
    if args.gene_table_output:
        frequency_df.to_csv(args.gene_table_output, sep='\t')
    elif args.function_table_output:
        frequency_df.to_csv(args.function_table_output, sep='\t')
    else:
        raise ConfigError("Neither gene nor function table output was specified.")

    if args.sum:
        run.info("Gene sum output", args.gene_table_output)
    elif args.average:
        run.info("Within-function gene average output", args.function_table_output)
    elif args.standard_deviation:
        run.info("Within-function gene standard deviation output", args.function_table_output)
    elif args.gene_table_output:
        run.info("Gene table output", args.gene_table_output)
    elif args.function_table_output:
        run.info("Function table output", args.function_table_output)

    # if args.sum or args.average:
    #     if args.gene_table_output:
    #         table_output = args.gene_table_output
    #     else:
    #         table_output = args.function_table_output
    #     frequency_df.to_csv(table_output, sep='\t')
    #     if args.sum:
    #         run.info("Gene sum output", table_output)
    #     elif args.average:
    #         run.info("Gene average output", table_output)
    # elif args.function_table_output:
    #     frequency_df.to_csv(args.function_table_output, sep='\t')
    #     run.info("Function table output", args.function_table_output)
    # else:
    #     frequency_df.to_csv(args.gene_table_output, sep='\t')
    #     run.info("Gene table output", args.gene_table_output)

def parse_select_functions_table(
    args: argparse.Namespace,
    select_function_sources: list[str]
) -> None:
    """
    Add select functions for codon frequency analysis from a tabular file.

    Parameters
    ==========
    args : argparse.Namespace
        Parsed command line arguments containing the attribute, 'select_functions_txt', with a
        string value, and 'function_accessions_dict' and 'function_names_dict' attributes.

    select_function_sources : list[str]
        Functional annotation sources to consider in calculating codon frequencies, appended with
        new sources found in the tabular file.
    """
    select_functions_df = pd.read_csv(
        args.select_functions_txt, sep='\t', header=None, names=['source', 'accession', 'name']
    ).fillna('')

    if len(select_functions_df) == 0:
        raise ConfigError("The table given by `--select-functions-txt` is empty.")

    if args.function_sources is not None and len(args.function_sources) == 0:
        # All function sources are to be considered, encompassing those in the file.
        pass
    else:
        # Add sources from the file to the list of all function sources to check for and load in the
        # genomes.
        for source in select_functions_df['source'].unique():
            if source not in select_function_sources:
                select_function_sources.append(source)

    for row in select_functions_df.itertuples(index=False):
        if not row.source:
            raise ConfigError(
                "Each row of the select functions table must have a source entry, as functions are "
                "allowed to come from different function annotation sources."
            )

        if not row.accession and not row.name:
            raise ConfigError(
                "Each row of the select functions table must have either an accession or function "
                "entry to define the function being sought in the annotation source."
            )

        if row.source == 'KEGG_BRITE' and not row.name:
            raise ConfigError(
                "In the select functions table, KEGG BRITE categories must be named in the third "
                "column. Categories do not have accessions in most BRITE hierarchies, and "
                "hierarchy accessions are not useful here."
            )

        source = row.source
        accession = row.accession
        name = row.name

        if accession:
            try:
                args.function_accessions_dict[source].append(accession)
            except KeyError:
                args.function_accessions_dict[source] = [accession]

        if name:
            try:
                args.function_names_dict[source].append(name)
            except KeyError:
                args.function_names_dict[source] = [name]

if __name__ == '__main__':
    parser = ArgumentParser(description=__description__)

    groupA = parser.add_argument_group(
        'SINGLE GENOME INPUTS',
        "Get frequencies from genes or functions in a single genome. A contigs database can be "
        "provided alone as an 'external' genome. An 'internal' genome (bin) also requires a "
        "profile database, collection name, and bin ID."
    )
    groupA.add_argument(*anvio.A('contigs-db'), **anvio.K('contigs-db', {'required': False}))
    groupA.add_argument(*anvio.A('profile-db'), **anvio.K('profile-db', {'required': False}))
    groupA.add_argument(*anvio.A('collection-name'), **anvio.K('collection-name'))
    groupA.add_argument(*anvio.A('bin-id'), **anvio.K('bin-id'))
    groupA.add_argument(
        '--gene-caller-ids', type=int, nargs='+', help="Select genes by ID, space-separated."
    )

    groupB = parser.add_argument_group(
        'MULTIPLE GENOME INPUTS',
        "Get frequencies from genes or functions in multiple genomes by providing internal and/or "
        "external genome files listing the genomes to analyze."
    )
    groupB.add_argument(*anvio.A('internal-genomes'), **anvio.K('internal-genomes'))
    groupB.add_argument(*anvio.A('external-genomes'), **anvio.K('external-genomes'))

    groupC = parser.add_argument_group(
        'OUTPUT FILES',
        "This program writes codon or amino acid frequency tables. When functions are analyzed, "
        "one of two possible files can be produced: a table of frequencies per gene or per "
        "function, using `--gene-table-output` or `--function-table-output`, respectively. "
        "Function table output sums codon frequencies across genes with the same function."
    )
    groupC.add_argument(*anvio.A('output-file'), **anvio.K('output-file'))
    groupC.add_argument(
        '--gene-table-output', help=(
            "A tab-delimited file of genes x codons or genes x amino acids. Index columns before "
            "frequency data contain genome names (if multiple genomes are considered) and gene "
            "caller IDs."
        )
    )
    groupC.add_argument(
        '--function-table-output', help=(
            "A tab-delimited file of functions x codons or functions x amino acids. Index columns "
            "before frequency data contain, respectively, genome names (if multiple genomes are "
            "considered) and function annotation sources, accessions, and names."
        )
    )
    groupC.add_argument(
        '--header-amino-acids', default=False, action='store_true', help=(
            "Include the amino acid for each codon in the column header of codon output, i.e., "
            "LysAAA instead of AAA."
        )
    )
    groupC.add_argument(
        '--infinity-to-zero', default=False, action='store_true', help=(
            "Replace NaN (empty) values in output with 0.0. NaN occurs with `--synonymous` when "
            "all codons for an amino acid are absent in a gene or function, resulting in 0/0. It "
            "also occurs with `--report-min-codons` and `--report-min-amino-acids`. Use with "
            "caution, for NaN and 0.0 mean different things and this will skew downstream analyses "
            "of synonymous relative frequencies, such as codon usage bias."
        )
    )
    groupC.add_argument(
        '--dont-report-codons', nargs='+', metavar='CODON', help=(
            "Exclude columns for the given codons from the output table."
        )
    )
    groupC.add_argument(
        '--report-codons', nargs='+', metavar='CODON', help=(
            "Only columns for the given codons are included in the output table."
        )
    )
    groupC.add_argument(
        '--dont-report-amino-acids', nargs='+', metavar='AMINO ACID', help=(
            "Exclude codon columns for the given amino acids from the output table."
        )
    )
    groupC.add_argument(
        '--report-amino-acids', nargs='+', metavar='AMINO ACID', help=(
            "Only codon columns for the given amino acids are included in the output table."
        )
    )

    groupD = parser.add_argument_group(
        'FREQUENCY STATISTICS',
        "Rather than absolute frequencies (default), relative frequencies or synonymous (per-amino "
        "acid) relative frequencies can be returned. Absolute and relative frequencies can be "
        "calculated for the sets of codons encoding the same amino acid rather than for individual "
        "codons. Aggregate statistics can also be calculated across genes: frequencies can be "
        "summed across genes in a genome, and the average and standard deviation can be calculated "
        "across genes in functions."
    )
    groupD.add_argument(*anvio.A('relative'), **anvio.K('relative'))
    groupD.add_argument(*anvio.A('synonymous'), **anvio.K('synonymous'))
    groupD.add_argument(*anvio.A('return-amino-acids'), **anvio.K('return-amino-acids'))
    groupD.add_argument(*anvio.A('encodings-txt'), **anvio.K('encodings-txt'))
    groupD.add_argument(*anvio.A('sum'), **anvio.K('sum'))
    groupD.add_argument(*anvio.A('average'), **anvio.K('average'))
    groupD.add_argument(*anvio.A('standard-deviation'), **anvio.K('standard-deviation'))

    groupE = parser.add_argument_group(
        'FUNCTIONS',
        "Frequencies can be calculated for functions rather than genes, summing the frequencies of "
        "the genes annotated by each function. Genes can also be filtered to those annotated with "
        "requested functions or annotated by requested function sources."
    )
    groupE.add_argument(*anvio.A('function-sources'), **anvio.K('function-sources'))
    groupE.add_argument(*anvio.A('function-accessions'), **anvio.K('function-accessions'))
    groupE.add_argument(*anvio.A('function-names'), **anvio.K('function-names'))
    groupE.add_argument(*anvio.A('select-functions-txt'), **anvio.K('select-functions-txt'))
    groupE.add_argument(*anvio.A('expect-functions'), **anvio.K('expect-functions'))
    groupE.add_argument(*anvio.A('shared-function-sources'), **anvio.K('shared-function-sources'))

    groupF = parser.add_argument_group(
        'CODON / GENE / FUNCTION FILTERS',
        "Codons can be selected a priori, e.g., ignore Ala codons. Rarer codons can be excluded, "
        "e.g., ignore amino acids that are decoded by < 3 codons in ≥ 90%% of genes. "
        "Genes/functions can be filtered by the number of codons they contain, e.g., ignore genes "
        "< 250 codons. Filters can improve the statistical utility of relative frequency data."
    )
    groupF.add_argument(*anvio.A('exclude-codons'), **anvio.K('exclude-codons'))
    groupF.add_argument(*anvio.A('include-codons'), **anvio.K('include-codons'))
    groupF.add_argument(*anvio.A('exclude-amino-acids'), **anvio.K('exclude-amino-acids'))
    groupF.add_argument(*anvio.A('include-amino-acids'), **anvio.K('include-amino-acids'))
    groupF.add_argument(*anvio.A('report-min-codons'), **anvio.K('report-min-codons'))
    groupF.add_argument(*anvio.A('report-min-amino-acids'), **anvio.K('report-min-amino-acids'))
    groupF.add_argument(*anvio.A('pansequence-min-codons'), **anvio.K('pansequence-min-codons'))
    groupF.add_argument(
        *anvio.A('pansequence-min-amino-acids'), **anvio.K('pansequence-min-amino-acids')
    )
    groupF.add_argument(*anvio.A('gene-min-codons'), **anvio.K('gene-min-codons'))
    groupF.add_argument(*anvio.A('min-codon-filter'), **anvio.K('min-codon-filter'))
    groupF.add_argument(*anvio.A('function-min-codons'), **anvio.K('function-min-codons'))

    args = parser.get_args(parser)

    try:
        main(args)
    except ConfigError as e:
        print(e)
        sys.exit(-1)
    except FilesNPathsError as e:
        print(e)
        sys.exit(-2)
