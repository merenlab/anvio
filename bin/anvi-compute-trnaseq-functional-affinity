#!/usr/bin/env python
# -*- coding: utf-8
"""Relate changes in tRNA-seq seed abundances to the codon usage of gene functions"""

import os
import sys
import pandas as pd
import scipy.cluster.hierarchy as hierarchy

from argparse import Namespace
from functools import partial

import anvio
import anvio.terminal as terminal
import anvio.constants as constants
import anvio.clustering as clustering
import anvio.codonusage as codonusage
import anvio.filesnpaths as filesnpaths
import anvio.genomictrnaseq as genomictrnaseq

from anvio import filesnpaths
from anvio.argparse import ArgumentParser
from anvio.errors import ConfigError, FilesNPathsError

with terminal.SuppressAllOutput():
    from ete3 import Tree


__author__ = "Developers of anvi'o (see AUTHORS.txt)"
__copyright__ = "Copyleft 2015-2022, the Meren Lab (http://merenlab.org/)"
__credits__ = []
__license__ = "GPL 3.0"
__version__ = anvio.__version__
__authors__ = ['semiller10']
__resources__ = []
__tags__ = ['trnaseq']
__requires__ = ['trnaseq-contigs-db', 'contigs-db']
__provides__ = []
__description__ = ("Relate changes in tRNA-seq seed abundances to the codon usage of gene "
                   "functions")


run = terminal.Run()
progress_quiet = terminal.Progress(verbose=False)


def main(args):
    ran_helper_mode = run_helper_modes(args)
    if ran_helper_mode:
        return

    sanity_check(args)
    # Add an argument the opposite of `no_codon_dendrogram`.
    args.plot_codon_dendrogram = True if args.plot and not args.no_codon_dendrogram else False

    affinities_dict = get_affinities(args)
    write_affinity_tables(args, affinities_dict)

    codon_frequency_dict = get_general_codon_frequencies(args, affinities_dict)
    write_general_codon_frequency_tables(args, codon_frequency_dict)

    # If no subsetting occurred, the returned subset affinity tables contain the identical data as
    # the passed affinity tables. Subset after generating the codon frequency tables, because those
    # tables can be saved to file, including all, rather than a subset of, genes or functions for
    # which affinity was calculated.
    subset_affinities_dict = subset_affinity_entries(args, affinities_dict)

    codon_linkage_dict = get_codon_linkage(args, codon_frequency_dict, subset_affinities_dict)
    write_codon_newick_files(args, codon_linkage_dict)

    sample_linkage_dict = get_sample_linkage(args, subset_affinities_dict)
    write_sample_newick_files(args, sample_linkage_dict)


def run_helper_modes(args):
    """Run helper functionality from Group 2 arguments."""
    if args.list_samples:
        print_sample_names(args.seeds_specific_txt)
        return True

    if args.get_default_decoding_weights:
        write_default_decoding_weights(args.get_default_decoding_weights)
        return True

    if args.get_annotation_blacklist:
        write_annotation_blacklist(
            args.get_annotation_blacklist[0], args.get_annotation_blacklist[1])
        return True

    return False


def print_sample_names(seeds_specific_txt):
    samples = genomictrnaseq.Affinitizer.list_sample_names(seeds_specific_txt)
    if not samples:
        raise ConfigError(
            "No sample names were found in `--seeds-specific-txt`, the table of tRNA-seq seed "
            "specific coverages generated by `anvi-tabulate-trnaseq`!")

    run = terminal.Run()
    run.info("tRNA-seq sample names", f"{', '.join(samples)}", nl_after=1)


def write_default_decoding_weights(output_path):
    filesnpaths.is_output_file_writable(output_path, ok_if_exists=False)
    with open(output_path) as output_file:
        for anticodon_wobble_nucleotide, anticodon_decoding_dict in \
            genomictrnaseq.Affinitizer.default_decoding_weights.items():
            for codon_wobble_nucleotide, decoding_weight in anticodon_decoding_dict.items():
                output_file.write(
                    f"{anticodon_wobble_nucleotide}\t{codon_wobble_nucleotide}\t"
                    f"{decoding_weight}\n")
    run.info("Default decoding weights file", output_path)


def write_annotation_blacklist(output_path, blacklist_name):
    filesnpaths.is_output_file_writable(output_path, ok_if_exists=False)
    if blacklist_name not in genomictrnaseq.Affinitizer.builtin_function_blacklists:
        raise ConfigError(
            f"An unrecognized built-in blacklist, {blacklist_name}, was provided. Here are the "
            "available options: "
            f"{', '.join(genomictrnaseq.Affinitizer.builtin_function_blacklists)}")
    with open(output_path) as output_file:
        for blacklist_pattern in genomictrnaseq.Affinitizer.builtin_function_blacklists[
            blacklist_name]:
            output_file.write(f"{blacklist_pattern}\n")


def sanity_check(args):
    """Check for valid combinations of arguments."""
    clustering.is_distance_metric_OK(args.codon_distance_metric)
    clustering.is_linkage_method_OK(args.codon_linkage_method)
    clustering.is_distance_and_linkage_compatible(
        args.codon_distance_metric, args.codon_linkage_method)
    clustering.is_distance_metric_OK(args.sample_distance_metric)
    clustering.is_linkage_method_OK(args.sample_linkage_method)
    clustering.is_distance_and_linkage_compatible(
        args.sample_distance_metric, args.sample_linkage_method)

    if not ((args.n_highest_affinity > 0 and args.n_lowest_affinity > 0) or
            (args.n_highest_affinity > 0 and args.n_lowest_affinity == 0) or
            (args.n_highest_affinity == 0 and args.n_lowest_affinity > 0) or
            (args.n_highest_affinity == -1 and args.n_lowest_affinity == -1)):
        raise ConfigError(
            "`--n-highest-affinity` and `--n-lowest-affinity` were passed an invalid combination "
            "of values.")

    if args.gene_caller_ids and not args.gene_affinity:
        args.gene_affinity = True
    if (args.gene_affinity and
        (args.function_source or
         args.function_accessions or
         args.function_names or
         args.select_functions_txt or
         args.lax_function_sources or
         args.function_blacklist_txt)):
        raise ConfigError(
            "`--gene-affinity` and `--gene-caller-ids` cannot be used with function options: "
            "`--function-sources`, `--function-accessions`, `--function-names`, "
            "`--select-functions-txt`, `--lax-function-sources`, and `--function-blacklist-txt`.")

    if args.plot_affinity_file:
        sanity_check_plot_affinity_file(args)
        return

    if ((args.no_codon_dendrogram or
         args.plot_sample_dendrogram or
         args.select_samples_txt or
         args.plot_codon_file or
         args.plot_codon_tree_file or
         args.plot_sample_file or
         args.plot_sample_tree_file) and
         not (args.plot and args.plot_affinity_file)):
        raise ConfigError(
            " `--no-codon-dendrogram`, `--plot-sample-dendrogram`, `--select-samples-txt`, "
            "`--plot-codon-file`, `--plot-codon-tree-file`, `--plot-sample-file`, and "
            "`--plot-sample-tree-file` must be used with `--plot`.")

    # Check arguments needed for computing affinities.
    if args.trnaseq_contigs_db is None:
        raise ConfigError(
            "`--trnaseq-contigs-db` is a required argument for computation of affinities.")
    if args.reference_sample is None:
        raise ConfigError(
            "`--reference-sample` is a required argument of computation of affinities.")

    # The following are checks on combinations of genomic inputs.
    if ((args.internal_genomes or args.external_genomes) and
        (args.contigs_db or args.profile_db or args.collection_name or
         args.bin_id or args.bin_ids_file or args.gene_caller_ids)):
        raise ConfigError(
            "`--internal-genomes` and `--external-genomes` cannot be used with other genomic input "
            "arguments.")
    if args.profile_db and not (args.contigs_db and args.collection_name):
        raise ConfigError("`--profile-db` also requires `--contigs-db` and `--collection-name`.")
    if args.collection_name and not (args.contigs_db and args.profile_db):
        raise ConfigError("`--collection-name` also requires `--contigs-db` and `--profile-db`.")
    if args.bin_id and args.bin_ids_file:
        raise ConfigError("`--bin-id` and `--bin-ids-file` cannot be used together.")
    if ((args.bin_id or args.bin_ids_file) and
        not (args.contigs_db and args.profile_db and args.collection_name)):
        raise ConfigError(
            "`--bin-id` and `--bin-ids-file` also require `--contigs-db`, `--profile-db`, and "
            "`--collection-name`.")

    if args.gene_caller_ids and not args.contigs_db:
        raise ConfigError("`--gene-caller-ids` also requires `--contigs-db`.")

    if (args.gene_affinity and
        (args.separate_function_sources or args.compare_all_function_sources)):
        raise ConfigError(
            "`--gene-affinity` cannot be used with `--separate-function-sources` or "
            "`--compare-all-function-sources`.")
    if args.separate_function_sources and args.compare_all_function_sources:
        raise ConfigError(
            "`--separate-function-sources` cannot be used with `--compare-all-function-sources`.")


def sanity_check_plot_affinity_file(args):
    """Check arguments needed for plotting stored data without computing affinities anew."""
    if not args.plot:
        args.plot = True

    if args.no_codon_dendrogram and (args.plot_codon_file or args.plot_codon_tree_file):
        raise ConfigError(
            "`--no-codon-dendrogram` cannot be used with `--plot-codon-file` or "
            "`--plot-codon-tree-file`.")
    elif not (args.plot_codon_file or args.plot_codon_tree_file):
        raise ConfigError(
            "To plot the dendrogram of displayed functions or genes, either pass a table of codon "
            "frequency data for tree calculation to `--plot-codon-file`, or pass a Newick tree to "
            "`--plot-codon-tree-file`.")

    if args.plot_codon_tree_file and args.save_codon_trees:
        raise ConfigError(
            "`--plot-codon-tree-file` cannot be used with `--save-codon-trees`. It does not make "
            "sense to resave the tree just loaded for plotting.")
    if args.plot_sample_tree_file and args.save_sample_trees:
        raise ConfigError(
            "`--plot-sample-tree-file` cannot be used with `--save-sample-trees`. It does not make "
            "sense to resave the tree just loaded for plotting.")
    if args.plot_sample_tree_file and args.normalization_methods:
        raise ConfigError(
            "`--plot-sample-tree-file` cannot be used with `--normalize-affinity`. The sample tree "
            "should be constructed from raw affinities or normalized affinities of a single type. "
            "The table of affinity data provided to `--plot-affinity-file` should be of the same "
            "type.")

    if args.select_samples_txt:
        filesnpaths.is_file_plain_text(args.select_samples_txt)
    if args.plot_codon_file:
        filesnpaths.is_file_tab_delimited(args.plot_codon_file)
    if args.plot_codon_tree_file:
        filesnpaths.is_proper_newick(args.plot_codon_tree_file)
    if args.plot_sample_tree_file:
        filesnpaths.is_proper_newick(args.plot_sample_tree_file)


def parse_decoding_weights_table(decoding_weights_txt):
    """Load the decoding weights table as a DataFrame."""
    if not decoding_weights_txt:
        return

    filesnpaths.is_file_tab_delimited(decoding_weights_txt)

    decoding_weights_df = pd.read_csv(decoding_weights_txt, sep='\t', index_col=0, header=0)

    is_formatted = True
    if decoding_weights_df.shape != genomictrnaseq.Affinitizer.default_decoding_weights_df.shape:
        is_formatted = False
    else:
        if not (decoding_weights_df.index ==
                genomictrnaseq.Affinitizer.default_decoding_weights_df.index).all():
            is_formatted = False
        if not (decoding_weights_df.columns ==
                genomictrnaseq.Affinitizer.default_decoding_weights_df.columns).all():
            is_formatted = False
    if not is_formatted:
        raise ConfigError(
            "The input decoding weights table is not formatted properly. The tab-delimited file "
            "generated by running this program with the sole argument, "
            "`--get-default-decoding-weights`, should be used as a template, with the row index of "
            "anticodon wobble nucleotides and column header of codon wobble nucleotides left "
            "unchanged.")

    return decoding_weights_df


def get_affinities(args):
    """
    Generate or load an affinity table, returning a dictionary containing one or more tables per
    genome, function or gene source, and normalization method.

    Parameters
    ==========
    args : argparse.Namespace

    Returns
    =======
    affinities_dict : dict
        This triple-nested dictionary has the following levels is structured as follows: genome name
        -> function or gene source -> normalization method -> affinity table.

        If considering genes rather than functions, the inner source dictionary will have the single
        key, 'all_genes'. If considering all functions, the inner source dictionary will have the
        single key, 'all_functions'. Otherwise, if separating function sources, the dictionary will
        have a key with the name of each source.

        The inner normalization method dictionary is keyed by normalization method, with 'raw'
        indicating unnormalized affinities, and the normalization choices of `--normalize-affinity`
        -- 'min_max', 'min_max_mean', and 'magnitude_min_max' -- being the other possible keys.

        The values of the innermost dictionary are affinity tables with rows representing functions
        or genes and columns representing tRNA-seq samples.
    """
    if args.plot_affinity_file:
        # Affinities are being plotted for a single genome but not computed anew.
        affinities_dict = load_affinities(args)
    else:
        # Compute affinities anew.
        affinities_dict = generate_affinities(args)

    return affinities_dict


def load_affinities(args):
    """Load single genome affinities for the purposes of plotting."""
    affinities_df = pd.read_csv(args.plot_affinity_file, sep='\t')
    # Make sure the loaded table is properly formatted.
    if affinities_df.columns[: 4] == [
        'genome_name', 'function_source', 'function_accession', 'function_name']:
        affinities_df = affinities_df.set_index(
            ['genome_name', 'function_source', 'function_accession', 'function_name'])
        args.gene_affinity = False
    elif affinities_df.columns[: 2] == ['genome_name', 'gene_callers_id']:
        affinities_df = affinities_df.set_index(['genome_name', 'gene_callers_id'])
        if args.gene_affinity is False:
            # Help out the user if they didn't explicitly indicate gene rather function affinity.
            args.gene_affinity = True
    else:
        raise ConfigError(
            f"The affinity table loaded from '{args.plot_affinity_file}' does not have the "
            "proper format, with the first columns being 'genome_name', 'function_source', "
            "'function_accession', and 'function_name' for function affinities or 'genome_name' "
            "and 'gene_callers_id' for gene affinities.")

    # If also loading a codon tree to plot a y-axis dendrogram, confirm that the table only contains
    # information on one genome.
    if (args.plot_codon_tree and
        affinities_df.index.get_level_values('genome_name').nunique() > 1):
        raise ConfigError(
            f"The provided affinity table, '{args.plot_affinity_table}', contains information on "
            f"more than one genome. However, the provided codon tree, '{args.plot_codon_tree}', is "
            "only allowed to contain information on one genome. Of course, the affinity table and "
            "codon tree should contain information on the same genome.")

    if args.select_samples_txt:
        # Select a subset of samples.
        with open(args.select_samples_txt) as select_samples_file:
            select_samples = [line.rstrip() for line in select_samples_file]

        missing_samples = set(select_samples).difference(set(affinities_df.columns))
        if missing_samples:
            raise ConfigError(
                "The following samples given in the `--select-samples-txt` file, "
                f"'{args.select_samples_txt}', are not found in the affinity table loaded from "
                f"from '{args.plot_affinity_file}'.")

        affinities_df = affinities_df[select_samples]

    # The dictionary of affinity tables will only have one key for a single genome in the outermost
    # dictionary.
    affinities_dict = {}
    genome_name = affinities_df.index.get_level_values('genome_name')[0]
    affinities_dict[genome_name] = source_dict = {}
    if args.gene_affinity:
        source_dict['genes'] = normalization_dict = {}
        if args.plot_codon_dendrogram:
            affinities_df = get_table_with_codon_tree_labels(args, affinities_df)
        normalization_dict['raw'] = affinities_df
        for normalization_method in args.normalization_methods:
            normalization_dict[normalization_method] = normalize_affinities_table(affinities_df)
    elif args.compare_all_function_sources:
        source_dict['all_functions'] = normalization_dict = {}
        if args.plot_codon_dendrogram:
            affinities_df = get_table_with_codon_tree_labels(args, affinities_df)
        normalization_dict['raw'] = affinities_df
        for normalization_method in args.normalization_methods:
            normalization_dict[normalization_method] = normalize_affinities_table(affinities_df)
    else:
        for source, source_df in affinities_df.groupby('function_source'):
            source_dict[source] = normalization_dict = {}
            if args.plot_codon_dendrogram:
                source_df = get_table_with_codon_tree_labels(args, source_df)
            normalization_dict['raw'] = source_df
            for normalization_method in args.normalization_methods:
                normalization_dict[normalization_method] = normalize_affinities_table(source_df)

    run.info(
        f"Input table of {'function' if args.gene_affinity else 'gene'} affinities",
        args.plot_affinity_file)

    return affinities_dict


def generate_affinities(args):
    """Generate affinities anew given one or more genomes."""
    args.decoding_weights = parse_decoding_weights_table(args.decoding_weights_txt)
    affinitizer = genomictrnaseq.Affinitizer(args)
    affinities_df = affinitizer.go()
    if len(affinities_df) == 0:
        raise ConfigError(
            "Affinity could not be calculated given the input data and/or filters applied to the "
            "data.")

    affinities_dict = {}
    for genome_name, genome_df in affinities_df.groupby('genome_name'):
        affinities_dict[genome_name] = source_dict = {}
        if args.gene_affinity:
            source_dict['genes'] = normalization_dict = {}
            normalization_dict['raw'] = affinities_df
            for normalization_method in args.normalization_methods:
                normalization_dict[normalization_method] = normalize_affinities_table(affinities_df)
        if args.compare_all_function_sources:
            source_dict['all_functions'] = normalization_dict = {}
            normalization_dict['raw'] = genome_df
            for normalization_method in args.normalization_methods:
                normalization_dict[normalization_method] = normalize_affinities_table(
                    genome_df, normalization_method)
        else:
            for source, source_df in genome_df.groupby('function_source'):
                source_dict[source] = normalization_dict = {}
                normalization_dict['raw'] = source_df
                for normalization_method in args.normalization_methods:
                    normalization_dict[normalization_method] = normalize_affinities_table(
                        source_df, normalization_method)

    if args.gene_affinity:
        source_dict['genes'] = normalization_dict = {}
        if args.plot_codon_dendrogram:
            affinities_df = get_table_with_codon_tree_labels(args, affinities_df)
        normalization_dict['raw'] = affinities_df
        for normalization_method in args.normalization_methods:
            normalization_dict[normalization_method] = normalize_affinities_table(affinities_df)
    elif args.compare_all_function_sources:
        source_dict['all_functions'] = normalization_dict = {}
        if args.plot_codon_dendrogram:
            affinities_df = get_table_with_codon_tree_labels(args, affinities_df)
        normalization_dict['raw'] = affinities_df
        for normalization_method in args.normalization_methods:
            normalization_dict[normalization_method] = normalize_affinities_table(affinities_df)
    else:
        for source, source_df in affinities_df.groupby('function_source'):
            source_dict[source] = normalization_dict = {}
            if args.plot_codon_dendrogram:
                source_df = get_table_with_codon_tree_labels(args, source_df)
            normalization_dict['raw'] = source_df
            for normalization_method in args.normalization_methods:
                normalization_dict[normalization_method] = normalize_affinities_table(source_df)

    return affinities_dict


def normalize_affinities_table(affinities_df, normalization_method):
    """Normalize affinities across functions or genes within a tRNA-seq sample using a specified
    normalization method."""
    # The following normalization functions are written to operate on a generic pandas Series.
    def min_max_normalize(series):
        normalized_series = series - series.min() / (series.max() - series.min())
        return normalized_series

    def min_max_mean_normalize(series):
        min_max_normalized_series = min_max_normalize(series)
        min_max_mean_normalized_series = \
            min_max_normalized_series - min_max_normalized_series.mean()
        return min_max_mean_normalized_series

    def magnitude_min_max_normalize(series):
        magnitude_series = series.abs()
        magnitude_min_max_normalized_series = min_max_normalize(magnitude_series)
        return magnitude_min_max_normalized_series

    def normalize(normalization_method, series):
        if normalization_method == 'min_max':
            normalized_series = min_max_normalize(series)
        elif normalization_method == 'min_max_mean':
            normalized_series = min_max_mean_normalize(series)
        elif normalization_method == 'magnitude_min_max':
            normalized_series = magnitude_min_max_normalize(series)
        return normalized_series

    # Assume that the normalization method has already been recognized as valid.
    normalized_affinities_df = affinities_df.transform(partial(normalize, normalization_method))

    return normalized_affinities_df


    """Write one or more affinity tables, if applicable."""
    if not args.plot_affinity_file:
        wrote_affinity_output = affinitizer.write_affinity_output(
            affinities_df,
            args.output_file,
            separate_genomes=args.separate_genomes,
            separate_function_sources=args.separate_function_sources,
            normalization_methods=args.normalize_affinity,
            normalize_all_function_sources=args.normalize_all_function_sources,
            no_raw_affinity=args.no_raw_affinity)
        if not wrote_affinity_output:
            run.warning(
                "No affinity output tables were stored. The flag, `--no-raw-affinity`, was used "
                "without `--normalization-methods`, so neither raw nor normalized affinities were "
                "written.")


def get_general_codon_frequencies(args, affinities_df):
    """Generate or load a table of absolute codon frequencies per function or gene."""
    if (args.plot and not args.plot_codon_file) or args.save_codon_frequencies:
        # Get the frequencies of codons encoding amino acids in the functions or genes (the rows)
        # reported in the affinity table. The general set of all codons encoding amino acids is
        # reported here, whereas codons that factor into affinity calculations are determined by the
        # detected tRNA transcripts.
        genome_names = affinities_df.index.get_level_values('genome_name').unique()
        if len(genome_names) == 1:
            # Add a first column to the index consisting of the genome name. With multiple genomes,
            # the table already has such an index.
            single_genome_name_index = genome_names[0]
        else:
            single_genome_name_index = None
        codon_frequency_df = genomictrnaseq.Affinitizer.get_general_codon_frequencies(
            args, affinities_df, single_genome_name_index=single_genome_name_index)

    if args.plot_codon_file:
        # Load absolute codon frequencies, from which codon trees are made.
        codon_frequency_df = pd.read_csv(args.plot_codon_file, sep='\t')

        if 'genome_name' not in codon_frequency_df.columns:
            raise ConfigError(f"The codon frequency table, loaded from '{args.plot_codon_file}', "
                              "does not but should contain a 'genome_name' column.")

        if (set(codon_frequency_df['genome_name']) !=
            set(affinities_df.index.get_level_values('genome_name'))):
            missing_codon_genome_names = set(
                affinities_df.index.get_level_values('genome_name')).difference(
                    set(codon_frequency_df['genome_name']))
            missing_affinity_genome_names = set(
                codon_frequency_df['genome_name']).difference(
                    set(affinities_df.index.get_level_values('genome_name')))
            if missing_codon_genome_names:
                codon_message = (
                    "The following genome names are in the affinity table but not the codon "
                    f"frequency table: {', '.join(missing_codon_genome_names)}.")
            elif missing_affinity_genome_names:
                codon_message = " "
            else:
                codon_message = ""
            if missing_affinity_genome_names:
                affinity_message = (
                    "The following genome names are in the codon frequency table but not the "
                    f"affinity table: {', '.join(missing_affinity_genome_names)}.")
                if missing_codon_genome_names:
                    affinity_message = " " + affinity_message
            else:
                affinity_message = ""
            raise ConfigError(
                f"The codon frequency table, loaded from '{args.plot_codon_file}', does not but "
                "should contain the same genome names as the affinity table, loaded from "
                f"'{args.plot_affinity_file}'.{codon_message}{affinity_message}")

        if affinities_df.index.names == [
            'genome_name', 'function_source', 'function_accession', 'function_name']:
            missing_cols = set(
                ['function_source', 'function_accession', 'function_name']).difference(
                    codon_frequency_df.columns)
            if missing_cols:
                raise ConfigError(
                    f"The codon frequency table, loaded from '{args.plot_codon_file}', does not "
                    "but should contain function columns with the headers, 'function_source', "
                    "'function_accession', and 'function_name'. The following of these columns "
                    f"is missing: {', '.join(missing_cols)}")
        elif affinities_df.index.names == ['genome_name', 'gene_callers_id']:
            if 'gene_callers_id' not in codon_frequency_df.columns:
                raise ConfigError(
                    f"The codon frequency table, loaded from '{args.plot_codon_file}', does not "
                    "but should contain a column with the header, 'gene_callers_id'.")
        else:
            raise ConfigError(
                "The affinity table index columns, as follows, are not recognized, though they "
                f"should already have been checked: {', '.join(affinities_df.index.names)}")

    if args.plot_codon_dendrogram:
        codon_frequency_df = codon_frequency_df.reset_index()
        codon_frequency_df['label'] = get_codon_tree_labels(codon_frequency_df)
        if args.gene_affinity:
            codon_frequency_df = affinities_df.set_index(
                ['genome_name', 'gene_callers_id', 'label'])
        else:
            codon_frequency_df = affinities_df.set_index(
                ['genome_name', 'function_source', 'function_accession', 'function_name', 'label'])

    return codon_frequency_df


def write_general_codon_frequency_tables(args, codon_frequency_df):
    """Write one or more codon frequency tables, if applicable."""
    if args.save_codon_frequencies:
        # Store codon frequency tables.
        output_basename, output_ext = os.path.splitext(args.output_path)
        template_output_path = output_basename + "-CODONS" + output_ext
        codonusage.write_split_codon_output(
            codon_frequency_df,
            template_output_path,
            separate_genomes=args.separate_genomes,
            separate_function_sources=args.separate_function_sources,
            output_basename=output_basename)


if __name__ == '__main__':
    parser = ArgumentParser(description=__description__)

    group1A = parser.add_argument_group(
        'TRNASEQ INPUTS',
        "TWO FILES are required to compute affinities: "
        "(1) A 'trnaseq'-variant contigs database produced by `anvi-merge-trnaseq` and integrated "
        "with (meta)genomic contigs database(s) by `anvi-integrate-trnaseq`, "
        "(2) a table of **specific** coverages of seeds produced by `anvi-tabulate-trnaseq` from "
        "the 'trnaseq'-variant contigs database (and other inputs).")
    group1A.add_argument(*anvio.A('trnaseq-contigs-db'),
                         **anvio.K('trnaseq-contigs-db', {'required': False}))
    group1A.add_argument(*anvio.A('seeds-specific-txt'),
                         **anvio.K('seeds-specific-txt', {'required': True}))

    group1B = parser.add_argument_group(
        'TRNASEQ SAMPLES',
        "A REFERENCE SAMPLE is required to compute affinities. Sample data is found in "
        "`seeds-specific-txt`. For convenience, running the current program with the "
        "`--seeds-specific-txt` argument and the `--list-sample` flag prints all sample names to "
        "the terminal.")
    group1B.add_argument(
        '-r', '--reference-sample', metavar='SAMPLE_NAME', type=str,
        help="The name of the tRNA-seq sample to be used as the reference in the calculation of "
             "affinities.")
    group1B.add_argument(
        '-n', '--nonreference-samples', metavar='SAMPLE_NAME[S]', nargs='+', type=str,
        help="Names of tRNA-seq samples, beside the specified reference sample, to be analyzed. By "
             "default, when this argument is not used, all of the samples in `seeds-specific-txt` "
             "are analyzed.")

    group1C = parser.add_argument_group(
        'GENOMIC INPUTS',
        "Different (meta)genomic inputs that have been integrated with the 'trnaseq'-variant "
        "contigs database can be provided. To find which (meta)genomes were integrated, run "
        "`anvi-integrate-trnaseq` with the `--list-genomes` flag. This will print the project "
        "names and hashes of (meta)genomic contigs databases and any bins (and their profile "
        "databases/collections) in which linked tRNA genes were found. Affinity is computed "
        "separately for each (meta)genome. For example, if two internal genomes are provided, "
        "then the affinity results for each will be returned. The following are valid inputs: "
        "(1) A single contigs database. This could represent a genome or metagenome. "
        "(2) A collection of bins, representing genomes in a metagenome. This requires a contigs "
        "database, profile database, and collection. "
        "(3) A single bin. This requires a contigs database, profile database, collection and bin "
        "ID. "
        "(4) Internal genomes, or a list of metagenomic bins (can be used with external genomes). "
        "(5) External genomes, or a list of contigs databases representing genomes (can be used "
        "with internal genomes).")
    group1C.add_argument(
        *anvio.A('contigs-db'), **anvio.K('contigs-db', {
            'required': False,
            'help': "Anvi'o (meta)genomic contigs database generated by "
                    "`anvi-gen-contigs-database`: NOT the tRNA-seq contigs database supplied to "
                    "`-t/--trnaseq-contigs-db`!"}))
    group1C.add_argument(*anvio.A('profile-db'), **anvio.K('profile-db', {'required': False}))
    group1C.add_argument(*anvio.A('collection-name'), **anvio.K('collection-name'))
    group1C.add_argument(*anvio.A('bin-id'), **anvio.K('bin-id'))
    group1C.add_argument(*anvio.A('bin-ids-file'), **anvio.K('bin-ids-file'))
    group1C.add_argument(*anvio.A('internal-genomes'), **anvio.K('internal-genomes'))
    group1C.add_argument(*anvio.A('external-genomes'), **anvio.K('external-genomes'))

    group1D = parser.add_argument_group(
        'TABULAR OUTPUTS',
        "This program requires an output file argument; by default, the table of affinities is "
        "stored there. Tables of normalized affinity data -- informative for inter-sample "
        "comparisons -- can be generated in addition to or instead of the affinity table. Separate "
        "tables of affinity data can be generated for each genome instead of concatenating results "
        "for multiple genomes in a single table. If more tables are generated than the single "
        "default, these are written to file paths derived from the provided output file path. If "
        "also graphing the results (see arguments under \"Graphical Outputs\" below), then graphs "
        "will be produced for each type of affinity table output specified.")
    group1D.add_argument(*anvio.A('output-file'), **anvio.K('output-file', {'required': True}))
    group1D.add_argument(
        '--separate-genomes', default=False, action='store_true',
        help="Write separate affinity output tables for each genome. The name of each genome/bin "
             "is inserted into the output path after a hyphen and before the extension, replacing "
             "any spaces in the name with underscores. The first column of each table remains the "
             "genome name.")
    group1D.add_argument(
        '--separate-function-sources', default=False, action='store_true',
        help="Write separate output tables for each function source. The name of each source is "
             "inserted into the output path after a hyphen and before the extension.")
    group1D.add_argument(
        '--normalize-affinity',
        nargs='+', choices=['min_max', 'min_max_mean', 'magnitude_min_max'], type=str,
        help="Output normalized affinity data. Normalized affinity data is useful for comparing "
             "which functions (or genes) are favored and disfavored by the tRNA pool across "
             "multiple (non-reference) samples, especially in graphs; without the option, "
             "`--shared-isoacceptors`, different isoacceptors can contribute to affinity in each "
             "sample given different sample coverage levels and the effects of isoacceptor "
             "filtering options, so the range of raw affinity values across functions in each "
             "sample can vary for this reason alone despite the same functions being favored and "
             "disfavored across samples. When multiple output tables are written, the name of the "
             "the normalization option (e.g., 'min_max', 'min_max_mean') is inserted into the "
             "output path after a hyphen and before the extension. 'raw' is similarly inserted "
             "into raw affinity output filepaths when normalization is used. "
             "(1) Min-max normalization of a function in a genome for a given tRNA-seq sample "
             "subtracts the function's affinity from the affinity of the minimum function and "
             "divides by the difference in affinity between the maximum and minimum functions. The "
             "minimum affinity -- which may be negative, indicating that the tRNA pool disfavors "
             "the function in the sample relative to the reference -- is normalized to 0. The "
             "maximum affinity -- which may also be negative -- is normalized to 1. "
             "(2) Min-max-mean normalization follows min-max normalization by subtraction of the "
             "mean to yield negative and positive values lying between -1 and 1. "
             "(3) Magnitude-min-max normalization takes the absolute value of affinity before "
             "min-max normalization to yield values that indicate the magnitude of the change in "
             "favorability of the tRNA pool towards functions, disregarding the direction of "
             "change.")
    group1D.add_argument(
        '--normalize-all-function-sources', default=False, action='store_true',
        help="When normalized affinities are calculated for multiple function sources (e.g., "
             "'KOfam', 'Pfam'), apply the normalization to all sources, so that, for example, "
             "KOfam and Pfam functions are compared to each other. This cannot be used with the "
             "option, `--separate-function-sources`.")
    group1D.add_argument(
        '--no-raw-affinity', default=False, action='store_true',
        help="Do not store tables of raw affinity data.")
    group1D.add_argument(
        '--save-codon-frequencies', default=False, action='store_true',
        help="Write a table of function or gene codon frequencies. If `--separate-genomes` or "
             "`--separate-function-sources` are used, then multiple files are written for each "
             "genome, function source, or combination of genome and source, with paths derived "
             "from the provided `--output-file` template. In these paths, '-CODONS' is added "
             "before the extension. The tables have the same row indices of genome, function, and "
             "gene information as the corresponding affinity tables. In plot output, these codon "
             "frequency data underlie the dendrograms of functions or genes.")

    group1E = parser.add_argument_group(
        'CLUSTERING',
        "The following arguments control hierarchical clustering and can be supplied for the "
        "production of Newick trees and plots. For both codon frequency and tRNA-seq sample "
        "clustering, the default distance metric is '{constants.distance_metric_default}' and "
        "the default linkage method is '{constants.linkage_method_default}'. All available "
        "distance metrics are listed in the help menu of the hierarchy.distance.pdist function in "
        "the scipy.cluster module. All available linkage methods are listed in the help menu of "
        "the hierarchy.linkage function in the scipy.cluster module.")
    group1E.add_argument(
        '--codon-distance', metavar='DISTANCE_METRIC', type=str,
        default=constants.distance_metric_default,
        help="The distance metric for the hierarchical clustering of functions or genes by their "
             "codon frequencies.")
    group1E.add_argument(
        '--codon-linkage', metavar='LINKAGE_METHOD', type=str,
        default=constants.linkage_method_default,
        help="The linkage method for the hierarchical clustering of functions or genes by their "
             "codon frequencies.")
    group1E.add_argument(
        '--save-codon-tree', default=False, action='store_true',
        help="Write a Newick-formatted tree of hierarchically clustered codon frequencies. If "
             "`--separate-genomes` or `--separate-function-sources` are used, then multiple tree "
             "files are written for each genome, function source, or combination of genome and "
             "source, with paths derived from the provided `--output-file` template. In these "
             "paths, '-CODONS' is added before the extension, and the extension is changed to "
             "'.tree'. In plot output, these trees are displayed as dendrograms of functions or "
             "genes.")
    group1E.add_argument(
        '--sample-distance', metavar='DISTANCE_METRIC', type=str,
        default=constants.distance_metric_default,
        help="The distance metric for the hierarchical clustering of tRNA-seq samples by their "
             "affinities.")
    group1E.add_argument(
        '--sample-linkage', metavar='LINKAGE_METHOD', type=str,
        help="The linkage method for the hierarchical clustering of tRNA-seq samples by their "
             "affinities.")
    group1E.add_argument(
        '--sample-tree', metavar='NEWICK', default=False, action='store_true',
        help="Write a Newick-formatted tree of hierarchically clustered tRNA-seq sample "
             "affinities. If `--separate-genomes` or `--separate-function-sources` are used, then "
             "multiple tree files are written for each genome, function source, or combination of "
             "genome and source, with paths derived from the provided `--output-file` template. In "
             "these paths, '-SAMPLE' is added before the extension, and the extension is changed "
             "to '.tree'. In plot output, these trees can be displayed as dendrograms of samples.")

    group1F = parser.add_argument_group(
        'PLOTS',
        "Static plots can be generated for each genome showing heatmaps of function (or gene) "
        "affinities, with each row being a function and each column being a tRNA-seq sample. A "
        "dendrogram orders the functions by their relative codon frequencies regardless of "
        "codon filters imposed by this program in the calculation of affinity. Optionally, a "
        "dendrogram orders the samples by the affinities of functions in the heatmap. These static "
        "plots are well-suited for visualizing a select number of functions, such as those most "
        "strongly favored (`--n-highest-affinity`) and most strongly disfavored "
        "(`--n-lowest-affinity`) by the tRNA pool. This program can generate plots in addition to "
        "tables, or it can be run again just to generate plots with affinity table and, "
        "optionally, codon frequency table and Newick tree inputs. The anvi'o interactive "
        "interface is better for visualizing all functions at once. `anvi-interactive` can take "
        "the affinity table and, optionally, Newick trees for ordering function data and sample "
        "layers -- such as those produced by `--save-codon-tree` and `--sample-tree`. (See "
        "https://merenlab.org/tutorials/interactive-interface/ and "
        "https://anvio.org/help/7/programs/anvi-interactive/"
        "#running-anvi-interactive-in-manual-mode)")
    group1F.add_argument(
        '--plot', nargs='?', const=True, default=False,
        help="Store static plots of genome function (or gene) affinity. If the program is run to "
             "calculate affinity, generating tables, then this option should be used as a flag. "
             "In this case, plots for each genome and affinity normalization method will be "
             "written to filepaths based on `--output-file`, with the extension changed to '.pdf', "
             "and the genome name and, if applicable, normalization method inserted before the "
             "extension following a hyphen. If the program is run solely to generate plots from an "
             "existing affinity table, then provide an output path for the plot. If the affinity "
             "table contains information on multiple genomes, then multiple plots will be "
             "generated, modifying each output path with the genome name as above. If the affinity "
             "table filepath contains a recognized normalization method preceding the extension, "
             "then it will also be included in the output filepath, and the scalebar of the "
             "heatmap will be adjusted accordingly, with 'min-max' and 'magnitude-min-max' being "
             "on a scale of 0 to 1 and 'min-max-mean' being on a scale of -1 to 1.")
    group1F.add_argument(
        '--n-highest-affinity', default=25, type=int,
        help="Plot this number of functions (or genes) with the highest affinities in the genome "
             "averaged across samples. Set this argument and `--n-lowest-affinity` to -1 to plot "
             "all functions. Set this argument to 0 and `--n-lowest-affinity` to a positive "
             "integer to only plot the lowest-affinity functions.")
    group1F.add_argument(
        '--n-lowest-affinity', default=25, type=int,
        help="Plot this number of functions (or genes) with the lowest affinities in the genome "
             "averaged across samples. Set this argument and `--n-highest-affinity` to -1 to plot "
             "all functions. Set this argument to 0 and `--n-highest-affinity` to a positive "
             "integer to only plot the highest-affinity functions.")
    group1F.add_argument(
        '--no-codon-dendrogram', default=False, action='store_true',
        help="This flag removes the dendrogram clustering functions or genes by their general "
             "codon composition.")
    group1F.add_argument(
        '--plot-sample-dendrogram', default=False, action='store_true',
        help="This flag adds a dendrogram clustering tRNA-seq samples. Without this flag, samples "
             "are ordered how they are input to the program or appear in the affinity table. "
             "Without `--plot-codon-file` or `--plot-sample-tree-file`, clustering is based on the "
             "affinities of the functions or genes displayed in the heatmap. Alternatively, a "
             "dendrogram can be computed from a codon frequency table supplied by "
             "`--plot-codon-file` or supplied as a Newick-formatted file by "
             "`--plot-sample-tree-file`. Clustering parameters can be altered with "
             "`--sample-distance` and `--sample-linkage`.")
    group1F.add_argument(
        '--plot-affinity-file', metavar='FILE_PATH', type=str,
        help="An affinity table is needed if running the program only to generate plots.")
    group1F.add_argument(
        '--select-samples-txt', metavar='FILE_PATH', type=str,
        help="Select a subset tRNA-seq samples in the loaded affinity table for plotting. The "
             "input file should have a single column of sample names. Available sample names in an "
             "affinity table can be printed to the terminal by running this program with the flag, "
             "`--list-samples`.")
    group1F.add_argument(
        '--plot-codon-file', metavar='FILE_PATH', type=str,
        help="A codon frequency table (see `--save-codon-frequencies` for the proper format) can "
             "be provided if running the program only to generate plots. The table must contain "
             "entries for the displayed functions or genes. Clustering parameters can be altered "
             "with `--sample-distance` and `--sample-linkage`.")
    group1F.add_argument(
        '--plot-codon-tree-file', metavar='NEWICK', type=str,
        help="A Newick-formatted tree of the displayed functions or genes can be provided if "
             "running the program only to generate plots. If the nodes of the tree represent genes "
             "rather than functions, use the flag, `--gene-affinity`.")
    group1F.add_argument(
        '--plot-sample-tree-file', metavar='NEWICK', type=str,
        help="A Newick-formatted tree of the tRNA-seq samples can be provided if running the "
             "program only to generate plots.")

    group1G = parser.add_argument_group(
        'FUNCTIONS',
        "Functional affinity can be computed for functions from any source, or, indeed, for genes, "
        "in which case, the term \"gene affinity\" should be used instead. Functions from multiple "
        "sources can be compared at once. This program makes no effort to avoid redundancy in the "
        "genes or functions that are analyzed: for example, if KEGG BRITE hierarchy categories are "
        "analyzed, the same gene can occur in multiple KEGG KOfams that define the categories and "
        "in multiple categories; the same KOfam can occur in multiple categories; and, since the "
        "categories are nested hierarchically, the same lower-level category can be encompassed by "
        "multiple higher-level categories.")
    group1G.add_argument(
        '-f', '--function-sources', nargs='*', type=str,
        default=genomictrnaseq.Affinitizer.default_function_sources,
        help="Calculate affinity for functions annotated by these sources, e.g., 'KOfam', "
             "'KEGG_BRITE', 'COG20_FUNCTION'. If `--function-sources` is used as a flag without "
             "any arguments, then every source will be considered.")
    group1G.add_argument(
        '--function-accessions', nargs='+', type=str,
        help="Calculate affinity for select functions with these accessions from the source "
             "provided in `--function-sources`. To get accessions from multiple sources, instead "
             "use `--select-functions-txt`.")
    group1G.add_argument(
        '--function-names', nargs='+', type=str,
        help="Calculate affinity for select functions with these names from the source provided in "
             "`--function-sources`. To get function names from multiple sources, instead use "
             "`--select-functions-txt`.")
    group1G.add_argument(
        '--select-functions-txt', metavar='FILE_PATH', type=str,
        help="Selected functions can be listed in this tab-delimited file of three columns. The "
             "first column should contain function annotation sources, the second column "
             "accessions, and the third function names. An entry in the source column is required "
             "in every row, and either an accession or name, or both, should also be in a row. "
             "The file should not have a header of column names.")
    group1G.add_argument(
        '--lax-function-sources', default=False, action='store_true',
        help="By default, without this flag, requested function annotation sources must have been "
             "run on every input (meta)genome. With this flag, it doesn't matter if any number of "
             "sources was not run on any number of input (meta)genomes.")
    group1G.add_argument(
        '--function-blacklist-txt', metavar='FILE_PATH', type=str,
        help="A single-column file of regular expressions that exclude functions from affinity "
             "calculations when patterns occur in function annotation strings. Built-in blacklists "
             "can be stored to file by running this program with the sole option, "
             "`--get-function-blacklist`. The generated file (indeed, any single-column file) can "
             "be provided with this argument. For example, if the file contains the regex, "
             "'[aA]rchaea', then functional annotations containing the substrings, 'archaea' or "
             "'Archaea', are disregarded.")
    group1G.add_argument(
        '--gene-affinity', default=False, action='store_true',
        help="Compute affinity for genes rather than functions.")
    group1G.add_argument(
        '--gene-caller-ids', nargs='+', type=int,
        help="Select genes by ID, space-separated, if using `--gene-affinity`, and genomic input "
             "from a single contigs database (not `--internal-genomes` or `--external-genomes`).")

    group1H = parser.add_argument_group(
        'SEED ASSIGNMENT',
        "It may not be possible to resolve tRNA transcripts to individual populations or genomes. "
        "tRNAs have relatively short sequences (~70-100 nt) that are often conserved across deep "
        "clades. By default, affinity calculations for functions in a genome conservatively use "
        "only those seeds with unique matches to tRNA genes in the genome, ignoring seeds that "
        "also match other genomes or unbinned contigs. Alternatively, either all or some seeds "
        "with an ambiguous source can be included in affinity calculations. "
        "`anvi-integrate-trnaseq` cannot have been run with the flag, "
        "`--unambiguous-genome-assignment`, as is the case by default, for the issue of seed "
        "ambiguity to factor into affinity calculations.")
    group1H.add_argument(
        '--seed-assignment',
        choices=['unambiguous_genome', 'unambiguous_db', 'ambiguous_all', 'ambiguous_choose'],
        type=str, default='unambiguous_genome',
        help="Control how tRNA-seq seeds assigned to tRNA genes that are not confined to a single "
             "genome -- \"ambiguous\" seeds -- affect affinity calculations. Ambiguous seeds may "
             "assigned to multiple genomes or a single genome and unbinned contigs. "
             "(1) `unambiguous_genome`: Only seeds assigned to a single INPUT (META)GENOME are "
             "used in affinity calculations. "
             "(2) `unambiguous_db`: Only seeds unambiguously assigned to each (meta)genome IN THE "
             "TRNASEQ CONTIGS DATABASE are used in affinity calculations. `anvi-integrate-trnaseq` "
             "can be run with any number of (meta)genomes, but a selection of these can be used as "
             "inputs to `anvi-compute-trnaseq-functional-affinity`. For example, `unambiguous_db` "
             "could be useful to calculate affinity for a single genome on the basis of "
             "unambiguous seeds despite multiple genomes having been integrated into the database."
             "(3): `ambiguous_all`: Both unambiguous and ambiguous seeds are used in affinity "
             "calculations. As a result, affinity calculations for different genomes will not be "
             "independent if ambiguous seeds are shared."
             "(4): `ambiguous_choose`: Try to convert ambiguous seeds to unambiguous seeds by "
             "seeking a likely genomic source for each ambiguous seed. The most likely genome is "
             "found from the summed coverages of unambiguous seeds from the competing genomes. "
             "For a most likely genome to be chosen, its summed coverage must exceed the "
             "second-highest summed coverage of a genome in every tRNA-seq sample by at least the "
             "`--min-coverage-ratio`. For example, an ambiguous seed matches genomes A, B, and C, "
             "and there are two samples, 1 and 2 (reference and non-reference). The summed "
             "coverage of unambiguous seeds assigned to genome A is 10000 in sample 1 and 5000 in "
             "sample 2; coverage for genome B, sample 1 is 1000 and genome B, sample 2 is 100; "
             "coverage for genome C, sample 1 is 500 and genome C, sample 2 is 1000. For sample 1, "
             "the ratio of highest to second-highest genome is 10000/1000 = 10, and for sample 2, "
             "the ratio is 5000/1000 = 5. In both samples, genome A has the highest total "
             "coverage. Therefore, with a `--min-coverage-ratio` 5, the ambiguous seed would be "
             "assigned to genome A for affinity calculations. With a `--min-coverage-ratio` >5, "
             "the ambiguous seed would be excluded from affinity calculations.")
    group1H.add_argument(
        '--min-coverage-ratio', metavar='FLOAT', type=float,
        default=genomictrnaseq.Affinitizer.default_min_coverage_ratio,
        help="This argument only applies to `--seed-assignment ambiguous_choose` and not any other "
             "values of `--seed-assignment`. See (4) in the `--seed-assignment` help message for "
             "details. An ambiguous seed matching multiple genomes can be salvaged for affinity "
             "calculations by assigning it to a single genome that is significantly more active "
             "than the other genomes and thereby the likely source of most of the tRNA molecules "
             "represented by the seed. The chosen genome must have at least `--min-coverage-ratio` "
             "greater summed coverage of unambiguous seeds than any of the other genomes in every "
             "tRNA-seq sample.")

    group1I = parser.add_argument_group(
        'ISOACCEPTOR PARAMETERS',
        "The calculation of affinity relies upon the abundances of tRNA isoacceptors, or groups of "
        "seeds with the same anticodon.")
    group1I.add_argument(
        '--min-coverage', metavar='INT', type=int,
        default=genomictrnaseq.Affinitizer.default_min_coverage,
        help="The coverage threshold for detection of a tRNA isoacceptor. Coverage is measured at "
             "the 3' (discriminator) nucleotide of the isoacceptor seeds. The threshold must be "
             "met in both the sample being analyzed and reference sample for the isoacceptor to "
             "contribute to affinity.")
    group1I.add_argument(
        '--exclude-unmodified-anticodons', nargs='+', type=str,
        help="Remove tRNA isoacceptors with the given unmodified anticodons from calculation of "
             "affinity. Note that this argument only handles unmodified anticodons. For example, "
             "'ACG' does not exclude 'ICG', and 'CAT' excludes tRNA-Met but not tRNA-Ile2, in "
             "which 'CAT' is modified to 'LAT' in bacteria. To exclude tRNA-Arg-ACG with the I34 "
             "modification and tRNA-Ile2, provide 'ICG LAT' with the option, "
             "`--exclude-modified-anticodons`. Exclusion of tRNAs by anticodon occurs before, and "
             "thereby affects, the `--min-isoacceptors` filter.")
    group1I.add_argument(
        '--exclude-modified-anticodons', nargs='+', type=str,
        help="Remove tRNA isoacceptors with the given modified anticodons from calculation of "
             "anticodon. Recognized modifications are wobble nucleotide I (inosine) (anticodons "
             "'INN', where 'N' is any nucleotide) and L (lysidine and, in this program, archaeal "
             "agmatidine, with the only anticodon recognized with this modification being 'LAT'). "
             "Exclusion of tRNAs by anticodon occurs before, and thereby affects, the "
             "`--min-isoacceptors` filter.")
    group1I.add_argument(
        '--min-isoacceptors', metavar='INT', type=int,
        default=genomictrnaseq.Affinitizer.default_min_isoacceptors,
        help="The minimum number of tRNA isoacceptors that need to be detected in a (meta)genomic "
             "source for affinity to be calculated. For example, say the minimum number of "
             "isoacceptors is 5, there are two internal genomes, A and B, and 10 isoacceptors pass "
             "the minimum coverage threshold in A whereas 4 isoacceptors pass the threshold in B. "
             "Affinity will be calculated for genome A but not B.")
    group1I.add_argument( # TODO: add this argument
        '--shared-isoacceptors', default=False, action='store_true',
        help="Retain isoacceptors that are shared among all of the input tRNA-seq samples (and "
             "that also pass the other isoacceptor filters). This facilitates the comparison of "
             "raw affinity data between multiple (non-reference) samples, because affinity is "
             "based on the same set of isoacceptors in each sample.")
    group1I.add_argument(
        '--decoding-weights-txt', metavar='FILE_PATH', type=str,
        help="A tab-delimited file of decoding weights, formatted identically to the file of "
             "default weights generated by running this program with the single option, "
             "`--get-default-decoding-weights`. The default weights used by this program are the "
             "s(i,j) values from Table 2 of dos Reis, Savva, and Wernisch (2004), which are used "
             "in their tRNA Adaptation Index (tAI) metric (https://doi.org/10.1093/nar/gkh834). "
             "s(i,j) means \"the selective constraint on the efficiency of the codon-anticodon "
             "coupling.\" Consistent with Table 2, weights are provided for the anticodon wobble "
             "nucleotides, A, C, G, T, I (inosine), and L (lysidine) -- these are the row index. "
             "The codon wobble nucleotides, A, C, G, and T, are the column header. A weight of 0 "
             "means that base pairing between the anticodon and codon is maximally efficient "
             "(e.g., C-G), whereas a weight of 1 means that base pairing is maximally inefficient "
             "(e.g., C-C).")

    group1J = parser.add_argument_group(
        'CODON FILTERS',
        "Functions and genes can be filtered by the number of codons that they contain, and "
        "codons can be selected for removal. The reliability or usefulness of the affinity metric "
        "is greater for functions with more analyzed codons decoded by measured tRNA-seq "
        "isoacceptors. Codon selection can be useful, for instance, in testing the effect of "
        "perturbations in the set of analyzed codons on the affinity results.")
    group1J.add_argument(
        '--min-analyzed-codons', type=int, default=0,
        help="Affinity is calculated for functions (or genes, with the flag, `--gene-affinity`) "
             "that contain at least this number of codons with corresponding tRNA-seq "
             "isoacceptors. For example, say a function contains gene sequences with 1,000 codons "
             "total, of which 300 can be decoded by isoacceptors screened for use in affinity "
             "calculations. If this argument is set to 500, then affinity would not be calculated "
             "for the function.")
    group1J.add_argument(
        '--function-min-total-codons', type=int, default=0,
        help="Affinity is calculated for functions that contain at least this number of codons "
             "total. This option can only be used with `--gene-affinity`.")
    group1J.add_argument(
        '--gene-min-total-codons', type=int, default=0,
        help="Genes must contain at least this number of codons total to contribute to affinity "
             "calculations. This option can only be used with `--gene-affinity`.")
    group1J.add_argument(
        '--exclude-codons', nargs='+', type=str,
        help="Remove the given codons from the calculation of affinity.")
    group1J.add_argument(
        '--exclude-amino-acids', nargs='+', type=str,
        help="Remove codons that decode the given amino acids from calculation of affinity.")

    group1K = parser.add_argument_group(
        'RAREFACTION STATISTICS',
        "Rarefaction of the tRNA isoacceptors used in calculation of affinity provides a means of "
        "evaluating how representative the isoacceptors are of the whole tRNA pool. The smaller "
        "the subset of isoacceptors involved in the calculation, the less reliable the metric is "
        "at evaluating the gene functions favored for translation by the tRNA pool. Affinity "
        "results that are sensitive to rarefaction indicate suggest that not enough isoacceptors "
        "were measured to achieve 'statistical significance'. Separate output files are produced "
        "for the results of rarefaction.")
    group1K.add_argument(
        '--rarefaction-limit', metavar='INT', type=int, default=0,
        help="Any positive integer for the rarefaction limit will trigger rarefaction of tRNA "
             "isoacceptors for recomputations of affinities. The rarefaction limit sets the number "
             "of randomly drawn subsamples of isoacceptors. For example, given a sample with 10 "
             "isoacceptors used in the calculation of affinity, there are 10 combinations of 1 "
             "isoacceptor that can be subsampled for recalculation with 1 isoacceptor, 45 "
             "combinations of 2 isoacceptors, ..., 252 combinations of 5 isoacceptors, ..., and 10 "
             "combinations of 9 isoacceptors. Setting a rarefaction limit of 100 would not affect "
             "any subsamples with 100 or fewer combinations, but would, for example, cause random "
             "subsampling of 100 of the 252 possible combinations of 5 isoacceptors.")

    group2 = parser.add_argument_group('INFO')
    group2.add_argument(
        '-l', '--list-samples', default=False, action='store_true',
        help="List the names of tRNA-seq samples in `seeds-specific-txt` by using this flag with "
             "the `--seeds-specific-txt` argument.")
    group2.add_argument(
        '-w', '--get-default-decoding-weights', metavar='FILE_PATH',
        help="Store a tab-delimited file of the default decoding weights used in affinity "
             "calculations. This file has the format of the input file needed for "
             "`--decoding-weights-txt`.")
    group2.add_argument(
        '-k', '--get-function-blacklist', nargs=2,
        help="Store a built-in blacklist of regular expressions that exclude functions from "
             "affinity calculations when patterns occur in function annotation strings. The first "
             "argument should be the output file path and the second argument should be the name "
             "of the built-in blacklist. The single-column output file (indeed, any single-column "
             "file) can be used with `--function-blacklist-txt`. Available named blacklists: "
             f"{', '.join(genomictrnaseq.Affinitizer.builtin_function_blacklists)}")

    args = parser.get_args(parser)

    try:
        main(args)
    except ConfigError as e:
        print(e)
        sys.exit(-1)
    except FilesNPathsError as e:
        print(e)
        sys.exit(-2)
