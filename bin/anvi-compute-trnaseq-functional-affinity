#!/usr/bin/env python
# -*- coding: utf-8
"""Relate changes in tRNA-seq seed abundances to the codon usage of gene functions"""

import os
import sys
import pandas as pd

import anvio
import anvio.terminal as terminal
import anvio.constants as constants
import anvio.clustering as clustering
import anvio.codonusage as codonusage
import anvio.filesnpaths as filesnpaths
import anvio.genomictrnaseq as genomictrnaseq

from anvio import filesnpaths
from anvio.argparse import ArgumentParser
from anvio.errors import ConfigError, FilesNPathsError

with terminal.SuppressAllOutput():
    from ete3 import Tree


__author__ = "Developers of anvi'o (see AUTHORS.txt)"
__copyright__ = "Copyleft 2015-2022, the Meren Lab (http://merenlab.org/)"
__credits__ = []
__license__ = "GPL 3.0"
__version__ = anvio.__version__
__authors__ = ['semiller10']
__resources__ = []
__tags__ = ['trnaseq']
__requires__ = ['trnaseq-contigs-db', 'contigs-db']
__provides__ = []
__description__ = ("Relate changes in tRNA-seq seed abundances to the codon usage of gene "
                   "functions")


run = terminal.Run()
progress_quiet = terminal.Progress(verbose=False)



def main(args):
    ran_helper_mode = run_helper_modes(args)
    if ran_helper_mode:
        return

    sanity_check(args)
    args.plot_codon_dendrogram = True if args.plot and not args.no_codon_dendrogram else False

    affinitizer, affinities_df = get_affinities(args)

    if args.plot and args.plot_affinity_file:
        if ((args.plot_codon_file and args.plot_codon_tree) or
            (not args.plot_codon_file and not args.plot_codon_tree)):
            raise ConfigError(
                "To plot the dendrogram of displayed functions or genes, either pass a table of "
                "codon frequency data for tree calculation to `--plot-codon-file`, or pass a "
                "Newick tree to `--plot-codon-tree`.")
        run.info_single("Input affinities to plot", args.plot_affinity_file)
        if args.plot_codon_file:
            run.info_single("Input codon frequency table", args.plot_codon_file)
        elif args.plot_codon_tree:
            run.info_single("Input codon frequency tree", args.plot_codon_tree)
        if args.plot_sample_tree:
            run.info_single("Input tRNA-seq sample tree", args.plot_sample_tree)

    sanity_check(args)

    args.decoding_weights = parse_decoding_weights_table(args.decoding_weights_txt)

    affinitizer = genomictrnaseq.Affinitizer(args)
    # Get a table of affinity results.
    affinities_df = affinitizer.go()
    if len(affinities_df) == 0:
        raise ConfigError("Affinity could not be calculated given the input data and/or filters "
                          "applied to the data.")
    # Write affinity tables.
    if not affinitizer.write_affinity_output(
        affinities_df,
        args.output_file,
        separate_genomes=args.separate_genomes,
        separate_function_sources=args.separate_function_sources,
        normalization_methods=args.normalize_affinity,
        normalize_all_function_sources=args.normalize_all_function_sources,
        no_raw_affinity=args.no_raw_affinity):
        run.warning(
            "No affinity output tables were stored. `--no-raw-affinity` was used without "
            "`--normalization-methods`, so neither raw nor normalized affinities were written.")

def run_helper_modes(args):
    """Run helper functionality from Group 2 arguments."""
    if args.list_samples:
        print_sample_names(args.seeds_specific_txt)
        return True

    if args.get_default_decoding_weights:
        write_default_decoding_weights(args.get_default_decoding_weights)
        return True

    if args.get_annotation_blacklist:
        write_annotation_blacklist(
            args.get_annotation_blacklist[0], args.get_annotation_blacklist[1])
        return True

    return False


def print_sample_names(seeds_specific_txt):
    sample_names = genomictrnaseq.Affinitizer.list_sample_names(seeds_specific_txt)
    if not sample_names:
        raise ConfigError("No sample names were found in `--seeds-specific-txt`, the table of "
                          "tRNA-seq seed specific coverages generated by `anvi-tabulate-trnaseq`!")

    run = terminal.Run()
    run.info("tRNA-seq sample names", f"{', '.join(sample_names)}", nl_after=1)


def write_default_decoding_weights(output_path):
    filesnpaths.is_output_file_writable(output_path, ok_if_exists=False)
    with open(output_path) as output_file:
        for anticodon_wobble_nucleotide, anticodon_decoding_dict in \
            genomictrnaseq.Affinitizer.default_decoding_weights.items():
            for codon_wobble_nucleotide, decoding_weight in anticodon_decoding_dict.items():
                output_file.write(f"{anticodon_wobble_nucleotide}\t"
                                  f"{codon_wobble_nucleotide}\t"
                                  f"{decoding_weight}\n")


def write_annotation_blacklist(output_path, blacklist_name):
    filesnpaths.is_output_file_writable(output_path, ok_if_exists=False)
    if blacklist_name not in genomictrnaseq.Affinitizer.builtin_function_blacklists:
        raise ConfigError(
            f"An unrecognized built-in blacklist, {blacklist_name}, was provided. Here are the "
            "available options: "
            f"{', '.join(genomictrnaseq.Affinitizer.builtin_function_blacklists)}")
    with open(output_path) as output_file:
        for blacklist_pattern in genomictrnaseq.Affinitizer.builtin_function_blacklists[
            blacklist_name]:
            output_file.write(f"{blacklist_pattern}\n")


def sanity_check(args):
    """Check for valid combinations of arguments."""
    ##################################################
    # Check arguments applicable when either computing or loading affinities.
    clustering.is_distance_metric_OK(args.codon_distance)
    clustering.is_linkage_method_OK(args.codon_linkage)
    clustering.is_distance_and_linkage_compatible(args.codon_distance, args.codon_linkage)
    clustering.is_distance_metric_OK(args.sample_distance)
    clustering.is_linkage_method_OK(args.sample_linkage)
    clustering.is_distance_and_linkage_compatible(args.sample_distance, args.sample_linkage)

    if not ((args.n_highest_affinity > 0 and args.n_lowest_affinity > 0) or
            (args.n_highest_affinity > 0 and args.n_lowest_affinity == 0) or
            (args.n_highest_affinity == 0 and args.n_lowest_affinity > 0) or
            (args.n_highest_affinity == -1 and args.n_lowest_affinity == -1)):
        raise ConfigError("`--n-highest-affinity` and `--n-lowest-affinity` were passed an invalid "
                          "combination of values.")
    ##################################################

    ##################################################
    # Check arguments needed for plotting stored data without computing affinities anew.
    if args.plot_affinity_file:
        if not args.plot:
            raise ConfigError("To plot stored affinity data, `--plot` and `--plot-affinity-file` "
                              "are needed, at minimum.")

        if args.no_codon_dendrogram and (args.plot_codon_file or args.plot_codon_tree_file):
            raise ConfigError("`--no-codon-dendrogram` cannot be used with `--plot-codon-file` or "
                              "`--plot-codon-tree-file`.")

        if ((args.plot_codon_file and args.plot_codon_tree_file) or
            (not args.plot_codon_file and not args.plot_codon_tree_file)):
            raise ConfigError(
                "To plot the dendrogram of displayed functions or genes, either pass a table of "
                "codon frequency data for tree calculation to `--plot-codon-file`, or pass a "
                "Newick tree to `--plot-codon-tree-file`.")

        if args.select_samples_txt:
            filesnpaths.is_file_plain_text(args.select_samples_txt)
        if args.plot_codon_file:
            filesnpaths.is_file_tab_delimited(args.plot_codon_file)
        if args.plot_codon_tree_file:
            filesnpaths.is_proper_newick(args.plot_codon_tree_file)
        if args.plot_sample_tree_file:
            filesnpaths.is_proper_newick(args.plot_sample_tree_file)

        return

    if ((args.no_codon_dendrogram or args.plot_sample_dendrogram or args.select_samples_txt or
         args.plot_codon_file or args.plot_codon_tree_file or
         args.plot_sample_file or args.plot_sample_tree_file) and
        not (args.plot or args.plot_affinity_file)):
        raise ConfigError(
            "`--no-codon-dendrogram`, `--plot-sample-dendrogram`, `--select-samples-txt`, "
            "`--plot-codon-file`, `--plot-codon-tree-file`, `--plot-sample-file`, and "
            "`--plot-sample-tree-file` must be used with `--plot` and `--plot-affinity-file`.")
    ##################################################

    ##################################################
    # Check arguments needed for computing affinties.
    if args.trnaseq_contigs_db is None:
        raise ConfigError("`--trnaseq-contigs-db` is a required argument for computation of "
                          "affinities.")
    if args.reference_sample is None:
        raise ConfigError("`--reference-sample` is a required argument of computation of "
                          "affinities.")

    # The following are checks on combinations of genomic inputs.
    if ((args.internal_genomes or args.external_genomes) and
        (args.contigs_db or args.profile_db or args.collection_name or
         args.bin_id or args.bin_ids_file or args.gene_caller_ids)):
        raise ConfigError("`--internal-genomes` and `--external-genomes` cannot be used with other "
                          "genome input arguments.")
    if args.profile_db and not (args.contigs_db and args.collection_name):
        raise ConfigError("`--profile-db` also requires `--contigs-db` and `--collection-name`.")
    if args.collection_name and not (args.contigs_db and args.profile_db):
        raise ConfigError("`--collection-name` also requires `--contigs-db` and `--profile-db`.")
    if args.bin_id and args.bin_ids_file:
        raise ConfigError("`--bin-id` and `--bin-ids-file` cannot be used together.")
    if ((args.bin_id or args.bin_ids_file) and
        not (args.contigs_db and args.profile_db and args.collection_name)):
        raise ConfigError("`--bin-id` and `--bin-ids-file` also require `--contigs-db`, "
                          "`--profile-db`, and `--collection-name`.")

    if args.gene_caller_ids and not args.contigs_db:
        raise ConfigError("`--gene-caller-ids` also requires `--contigs-db`.")

    if args.separate_function_sources and args.normalize_all_function_sources:
        raise ConfigError("`--separate-function-sources` cannot be used with "
                          "`--normalize-all-function-sources`.")
    ##################################################



    clustering.is_distance_metric_OK(args.codon_distance)
    clustering.is_linkage_method_OK(args.codon_linkage)
    clustering.is_distance_and_linkage_compatible(args.codon_distance, args.codon_linkage)
    clustering.is_distance_metric_OK(args.sample_distance)
    clustering.is_linkage_method_OK(args.sample_linkage)
    clustering.is_distance_and_linkage_compatible(args.sample_distance, args.sample_linkage)


def parse_decoding_weights_table(decoding_weights_txt):
    """Load the decoding weights table as a DataFrame."""
    if not decoding_weights_txt:
        return

    filesnpaths.is_file_tab_delimited(decoding_weights_txt)

    decoding_weights_df = pd.read_csv(decoding_weights_txt, sep='\t', index_col=0, header=0)

    is_formatted = True
    if decoding_weights_df.shape != genomictrnaseq.Affinitizer.default_decoding_weights_df.shape:
        is_formatted = False
    else:
        if not (decoding_weights_df.index ==
                genomictrnaseq.Affinitizer.default_decoding_weights_df.index).all():
            is_formatted = False
        if not (decoding_weights_df.columns ==
                genomictrnaseq.Affinitizer.default_decoding_weights_df.columns).all():
            is_formatted = False
    if not is_formatted:
        raise ConfigError(
            "The input decoding weights table is not formatted properly. The tab-delimited file "
            "generated by running this program with the sole argument, "
            "`--get-default-decoding-weights`, should be used as a template, with the row index of "
            "anticodon wobble nucleotides and column header of codon wobble nucleotides left "
            "unchanged.")

    return decoding_weights_df


def get_affinities(args):
    """Generate or load an affinities table."""
    if args.plot_affinity_file:
        # Affinities are being plotted but not computed anew.
        affinitizer = None

        run.info("Input affinities to plot", args.plot_affinity_file)
        if args.plot_codon_file:
            run.info("Input codon frequency table", args.plot_codon_file)
        elif args.plot_codon_tree_file:
            run.info("Input codon frequency tree", args.plot_codon_tree_file)
        if args.plot_sample_tree_file:
            run.info("Input tRNA-seq sample tree", args.plot_sample_tree_file)

        # Load an affinity table, and make sure it looks like one.
        affinities_df = pd.read_csv(args.plot_affinity_file, sep='\t')
        if affinities_df.columns[: 4] == [
            'genome_name', 'function_source', 'function_accession', 'function_name']:
            affinities_df = affinities_df.set_index(
                ['genome_name', 'function_source', 'function_accession', 'function_name'])
            run.info.single("Loaded function affinities")
        elif affinities_df.columns[: 2] == ['genome_name', 'gene_callers_id']:
            affinities_df = affinities_df.set_index(['genome_name', 'gene_callers_id'])
            if args.gene_affinity is False:
                # Help out the user.
                args.gene_affinity = True
            run.info.single("Loaded gene affinities")
        else:
            raise ConfigError(
                f"The affinity table loaded from '{args.plot_affinity_file}' does not have the "
                "proper format, with the first columns being 'genome_name', 'function_source', "
                "'function_accession', and 'function_name' for functional affinities or "
                "'genome_name' and 'gene_callers_id' for gene affinities.")

        # If also loading a codon tree to plot a y-axis dendrogram, confirm that the affinity table
        # only contains information on one genome, like a proper codon tree.
        if (args.plot_codon_tree and
            affinities_df.index.get_level_values('genome_name').nunique() > 1):
            raise ConfigError(
                f"The provided affinity table, '{args.plot_affinity_table}', contains information "
                "on more than one genome. However, the provided codon tree, "
                f"'{args.plot_codon_tree}', is only allowed to contain information on one genome. "
                "When loading both an affinity table and codon tree, they should contain "
                "information on the same genome.")

        if args.select_samples_txt:
            # Select a subset of samples.
            with open(args.select_samples_txt) as select_samples_file:
                select_samples = [line.rstrip() for line in select_samples_file]

            missing_samples = set(select_samples).difference(set(affinities_df.columns))
            if missing_samples:
                raise ConfigError(
                    "The following samples given in the `--select-samples-txt` file, "
                    "'{args.select_samples_txt}', are not found in the affinities table loaded "
                    "from '{args.plot_affinity_file}'.")

            affinities_df = affinities_df[select_samples]
    else:
        # Rather than loading an affinity table, compute one anew.
        args.decoding_weights = parse_decoding_weights_table(args.decoding_weights_txt)
        affinitizer = genomictrnaseq.Affinitizer(args)
        affinities_df = affinitizer.go()
        if len(affinities_df) == 0:
            raise ConfigError("Affinity could not be calculated given the input data and/or "
                              "filters applied to the data.")

    if args.plot_codon_dendrogram:
        # Create a column in the affinity table containing function or gene names formatted like the
        # labels stored in a codon tree. This allows the affinity table to be cross-referenced with
        # codon trees.
        affinities_df = affinities_df.reset_index()
        affinities_df['label'] = get_codon_tree_labels(affinities_df)
        if args.gene_affinity:
            affinities_df = affinities_df.set_index(['genome_name', 'gene_callers_id', 'label'])
        else:
            affinities_df = affinities_df.set_index(
                ['genome_name', 'function_source', 'function_accession', 'function_name', 'label'])

    return affinitizer, affinities_df
if __name__ == '__main__':
    parser = ArgumentParser(description=__description__)

    group1A = parser.add_argument_group(
        'TRNASEQ INPUTS',
        "TWO FILES are required to compute affinities: "
        "(1) A 'trnaseq'-variant contigs database produced by `anvi-merge-trnaseq` and integrated "
        "with (meta)genomic contigs database(s) by `anvi-integrate-trnaseq`, "
        "(2) a table of **specific** coverages of seeds produced by `anvi-tabulate-trnaseq` from "
        "the 'trnaseq'-variant contigs database (and other inputs).")
    group1A.add_argument(*anvio.A('trnaseq-contigs-db'),
                         **anvio.K('trnaseq-contigs-db', {'required': False}))
    group1A.add_argument(*anvio.A('seeds-specific-txt'),
                         **anvio.K('seeds-specific-txt', {'required': True}))

    group1B = parser.add_argument_group(
        'TRNASEQ SAMPLES',
        "A REFERENCE SAMPLE is required to compute affinities. Sample data is found in "
        "`seeds-specific-txt`. For convenience, running the current program with the "
        "`--seeds-specific-txt` argument and the `--list-sample` flag prints all sample names to "
        "the terminal.")
    group1B.add_argument(
        '-r', '--reference-sample', metavar='SAMPLE_NAME', type=str,
        help="The name of the tRNA-seq sample to be used as the reference in the calculation of "
             "affinities.")
    group1B.add_argument(
        '-n', '--nonreference-samples', metavar='SAMPLE_NAME[S]', nargs='+', type=str,
        help="Names of tRNA-seq samples, beside the specified reference sample, to be analyzed. By "
             "default, when this argument is not used, all of the samples in `seeds-specific-txt` "
             "are analyzed.")

    group1C = parser.add_argument_group(
        'GENOMIC INPUTS',
        "Different (meta)genomic inputs that have been integrated with the 'trnaseq'-variant "
        "contigs database can be provided. To find which (meta)genomes were integrated, run "
        "`anvi-integrate-trnaseq` with the `--list-genomes` flag. This will print the project "
        "names and hashes of (meta)genomic contigs databases and any bins (and their profile "
        "databases/collections) in which linked tRNA genes were found. Affinity is computed "
        "separately for each (meta)genome. For example, if two internal genomes are provided, "
        "then the affinity results for each will be returned. The following are valid inputs: "
        "(1) A single contigs database. This could represent a genome or metagenome. "
        "(2) A collection of bins, representing genomes in a metagenome. This requires a contigs "
        "database, profile database, and collection. "
        "(3) A single bin. This requires a contigs database, profile database, collection and bin "
        "ID. "
        "(4) Internal genomes, or a list of metagenomic bins (can be used with external genomes). "
        "(5) External genomes, or a list of contigs databases representing genomes (can be used "
        "with internal genomes).")
    group1C.add_argument(
        *anvio.A('contigs-db'), **anvio.K('contigs-db', {
            'required': False,
            'help': "Anvi'o (meta)genomic contigs database generated by "
                    "`anvi-gen-contigs-database`: NOT the tRNA-seq contigs database supplied to "
                    "`-t/--trnaseq-contigs-db`!"}))
    group1C.add_argument(*anvio.A('profile-db'), **anvio.K('profile-db', {'required': False}))
    group1C.add_argument(*anvio.A('collection-name'), **anvio.K('collection-name'))
    group1C.add_argument(*anvio.A('bin-id'), **anvio.K('bin-id'))
    group1C.add_argument(*anvio.A('bin-ids-file'), **anvio.K('bin-ids-file'))
    group1C.add_argument(*anvio.A('internal-genomes'), **anvio.K('internal-genomes'))
    group1C.add_argument(*anvio.A('external-genomes'), **anvio.K('external-genomes'))

    group1D = parser.add_argument_group(
        'TABULAR OUTPUTS',
        "This program requires an output file argument; by default, the table of affinities is "
        "stored there. Tables of normalized affinity data -- informative for inter-sample "
        "comparisons -- can be generated in addition to or instead of the affinity table. Separate "
        "tables of affinity data can be generated for each genome instead of concatenating results "
        "for multiple genomes in a single table. If more tables are generated than the single "
        "default, these are written to file paths derived from the provided output file path. If "
        "also graphing the results (see arguments under \"Graphical Outputs\" below), then graphs "
        "will be produced for each type of affinity table output specified.")
    group1D.add_argument(*anvio.A('output-file'), **anvio.K('output-file', {'required': True}))
    group1D.add_argument(
        '--separate-genomes', default=False, action='store_true',
        help="Write separate affinity output tables for each genome. The name of each genome/bin "
             "is inserted into the output path after a hyphen and before the extension, replacing "
             "any spaces in the name with underscores. The first column of each table remains the "
             "genome name.")
    group1D.add_argument(
        '--separate-function-sources', default=False, action='store_true',
        help="Write separate output tables for each function source. The name of each source is "
             "inserted into the output path after a hyphen and before the extension.")
    group1D.add_argument(
        '--normalize-affinity',
        nargs='+', choices=['min_max', 'min_max_mean', 'magnitude_min_max'], type=str,
        help="Output normalized affinity data. Normalized affinity data is useful for comparing "
             "which functions (or genes) are favored and disfavored by the tRNA pool across "
             "multiple (non-reference) samples, especially in graphs; without the option, "
             "`--shared-isoacceptors`, different isoacceptors can contribute to affinity in each "
             "sample given different sample coverage levels and the effects of isoacceptor "
             "filtering options, so the range of raw affinity values across functions in each "
             "sample can vary for this reason alone despite the same functions being favored and "
             "disfavored across samples. When multiple output tables are written, the name of the "
             "the normalization option (e.g., 'min_max', 'min_max_mean') is inserted into the "
             "output path after a hyphen and before the extension. 'raw' is similarly inserted "
             "into raw affinity output filepaths when normalization is used. "
             "(1) Min-max normalization of a function in a genome for a given tRNA-seq sample "
             "subtracts the function's affinity from the affinity of the minimum function and "
             "divides by the difference in affinity between the maximum and minimum functions. The "
             "minimum affinity -- which may be negative, indicating that the tRNA pool disfavors "
             "the function in the sample relative to the reference -- is normalized to 0. The "
             "maximum affinity -- which may also be negative -- is normalized to 1. "
             "(2) Min-max-mean normalization follows min-max normalization by subtraction of the "
             "mean to yield negative and positive values lying between -1 and 1. "
             "(3) Magnitude-min-max normalization takes the absolute value of affinity before "
             "min-max normalization to yield values that indicate the magnitude of the change in "
             "favorability of the tRNA pool towards functions, disregarding the direction of "
             "change.")
    group1D.add_argument(
        '--normalize-all-function-sources', default=False, action='store_true',
        help="When normalized affinities are calculated for multiple function sources (e.g., "
             "'KOfam', 'Pfam'), apply the normalization to all sources, so that, for example, "
             "KOfam and Pfam functions are compared to each other. This cannot be used with the "
             "option, `--separate-function-sources`.")
    group1D.add_argument(
        '--no-raw-affinity', default=False, action='store_true',
        help="Do not store tables of raw affinity data.")
    group1D.add_argument(
        '--codon-frequencies', default=False, action='store_true',
        help="Write a table of function or gene codon frequencies. If `--separate-genomes` or "
             "`--separate-function-sources` are used, then multiple files are written for each "
             "genome, function source, or combination of genome and source, with paths derived "
             "from the provided `--output-file` template. In these paths, '-CODONS' is added "
             "before the extension. The tables have the same row indices of genome, function, and "
             "gene information as the corresponding affinity tables. In plot output, these codon "
             "frequency data underlie the dendrograms of functions or genes.")

    group1E = parser.add_argument_group(
        'CLUSTERING',
        "The following arguments control hierarchical clustering and can be supplied for the "
        "production of Newick trees and plots. For both codon frequency and tRNA-seq sample "
        "clustering, the default distance metric is '{constants.distance_metric_default}' and "
        "the default linkage method is '{constants.linkage_method_default}'. All available "
        "distance metrics are listed in the help menu of the hierarchy.distance.pdist function in "
        "the scipy.cluster module. All available linkage methods are listed in the help menu of "
        "the hierarchy.linkage function in the scipy.cluster module.")
    group1E.add_argument(
        '--codon-distance', metavar='DISTANCE_METRIC', type=str,
        default=constants.distance_metric_default,
        help="The distance metric for the hierarchical clustering of functions or genes by their "
             "codon frequencies.")
    group1E.add_argument(
        '--codon-linkage', metavar='LINKAGE_METHOD', type=str,
        default=constants.linkage_method_default,
        help="The linkage method for the hierarchical clustering of functions or genes by their "
             "codon frequencies.")
    group1E.add_argument(
        '--codon-tree', default=False, action='store_true',
        help="Write a Newick-formatted tree of hierarchically clustered codon frequencies. If "
             "`--separate-genomes` or `--separate-function-sources` are used, then multiple tree "
             "files are written for each genome, function source, or combination of genome and "
             "source, with paths derived from the provided `--output-file` template. In these "
             "paths, '-CODONS' is added before the extension, and the extension is changed to "
             "'.tree'. In plot output, these trees are displayed as dendrograms of functions or "
             "genes.")
    group1E.add_argument(
        '--sample-distance', metavar='DISTANCE_METRIC', type=str,
        default=constants.distance_metric_default,
        help="The distance metric for the hierarchical clustering of tRNA-seq samples by their "
             "affinities.")
    group1E.add_argument(
        '--sample-linkage', metavar='LINKAGE_METHOD', type=str,
        help="The linkage method for the hierarchical clustering of tRNA-seq samples by their "
             "affinities.")
    group1E.add_argument(
        '--sample-tree', metavar='NEWICK', default=False, action='store_true',
        help="Write a Newick-formatted tree of hierarchically clustered tRNA-seq sample "
             "affinities. If `--separate-genomes` or `--separate-function-sources` are used, then "
             "multiple tree files are written for each genome, function source, or combination of "
             "genome and source, with paths derived from the provided `--output-file` template. In "
             "these paths, '-SAMPLE' is added before the extension, and the extension is changed "
             "to '.tree'. In plot output, these trees can be displayed as dendrograms of samples.")

    group1F = parser.add_argument_group(
        'PLOTS',
        "Static plots can be generated for each genome showing heatmaps of function (or gene) "
        "affinities, with each row being a function and each column being a tRNA-seq sample. A "
        "dendrogram orders the functions by their overall raw codon frequencies regardless of "
        "codon filters imposed by this program in the calculation of affinity. Optionally, a "
        "dendrogram orders the samples by the affinities of functions in the heatmap. These static "
        "plots are well-suited for visualizing a select number of functions, such as those most "
        "strongly favored (`--n-highest-affinity`) and most strongly disfavored "
        "(`--n-lowest-affinity`) by the tRNA pool. This program can generate plots alongside "
        "tables, or it can be run again just to generate plots with affinity table and, "
        "optionally, codon frequency table and Newick tree inputs. The anvi'o interactive "
        "interface is better for visualizing all functions at once. `anvi-interactive` can take "
        "the affinity table and, optionally, Newick trees for ordering function data and sample "
        "layers -- such as those produced by `--codon-tree` and `--sample-tree`. (See "
        "https://merenlab.org/tutorials/interactive-interface/ and "
        "https://anvio.org/help/7/programs/anvi-interactive/"
        "#running-anvi-interactive-in-manual-mode)")
    group1F.add_argument(
        '--plot', nargs='?', const=True, default=False,
        help="Store static plots of genome function (or gene) affinity. If the program is run to "
             "calculate affinity, generating tables, then this option should be used as a flag. "
             "In this case, plots for each genome and affinity normalization method will be "
             "written to filepaths based on `--output-file`, with the extension changed to '.pdf', "
             "and the genome name and, if applicable, normalization method inserted before the "
             "extension following a hyphen. If the program is run solely to generate plots from an "
             "existing affinity table, then provide an output path for the plot. If the affinity "
             "table contains information on multiple genomes, then multiple plots will be "
             "generated, modifying each output path with the genome name as above. If the affinity "
             "table filepath contains a recognized normalization method preceding the extension, "
             "then it will also be included in the output filepath, and the scalebar of the "
             "heatmap will be adjusted accordingly, with 'min-max' and 'magnitude-min-max' being "
             "on a scale of 0 to 1 and 'min-max-mean' being on a scale of -1 to 1.")
    group1F.add_argument(
        '--n-highest-affinity', default=25, type=int,
        help="Plot this number of functions or genes with the highest affinities in the genome.")
    group1F.add_argument(
        '--n-lowest-affinity', default=25, type=int,
        help="Plot this number of functions or genes with the lowest affinities in the genome.")
    group1F.add_argument(
        '--sample-dendrogram', default=False, action='store_true',
        help="This flag adds a dendrogram clustering tRNA-seq samples. Without this flag, samples "
             "are ordered how they are input to the program or appear in the affinity table. "
             "Without `--plot-codon-file` or `--plot-sample-tree`, clustering is based on the "
             "affinities of the functions or genes displayed in the heatmap. Alternatively, a "
             "dendrogram can be computed from a codon frequency table supplied by "
             "`--plot-codon-file` or supplied as a Newick-formatted file by `--plot-sample-tree`. "
             "Clustering parameters can be altered with `--sample-distance` and "
             "`--sample-linkage`.")
    group1F.add_argument(
        '--plot-affinity-file', metavar='FILE_PATH', type=str,
        help="An affinity table is needed if running the program only to generate plots.")
    group1F.add_argument(
        '--plot-codon-file', metavar='FILE_PATH', type=str,
        help="A codon frequency table (see `--codon-frequencies` for the proper format) can be "
             "provided if running the program only to generate plots. The table must contain "
             "entries for the displayed functions or genes. Clustering parameters can be altered "
             "with `--sample-distance` and `--sample-linkage`.")
    group1F.add_argument(
        '--plot-codon-tree', metavar='NEWICK', type=str,
        help="A Newick-formatted tree of the displayed functions or genes can be provided if "
             "running the program only to generate plots.")
    group1F.add_argument(
        '--plot-sample-tree', metavar='NEWICK', type=str,
        help="A Newick-formatted tree of the tRNA-seq samples can be provided if running the "
             "program only to generate plots.")

    group1G = parser.add_argument_group(
        'FUNCTIONS',
        "Functional affinity can be computed for functions from any source, or, indeed, for genes, "
        "in which case, the term \"gene affinity\" should be used instead. Functions from multiple "
        "sources can be compared at once. This program makes no effort to avoid redundancy in the "
        "genes or functions that are analyzed: for example, if KEGG BRITE hierarchy categories are "
        "analyzed, the same gene can occur in multiple KEGG KOfams that define the categories and "
        "in multiple categories; the same KOfam can occur in multiple categories; and, since the "
        "categories are nested hierarchically, the same lower-level category can be encompassed by "
        "multiple higher-level categories.")
    group1G.add_argument(
        '-f', '--function-sources', nargs='*', type=str,
        default=genomictrnaseq.Affinitizer.default_function_sources,
        help="Calculate affinity for functions annotated by these sources, e.g., 'KOfam', "
             "'KEGG_BRITE', 'COG20_FUNCTION'. If `--function-sources` is used as a flag without "
             "any arguments, then every source will be considered.")
    group1G.add_argument(
        '--function-accessions', nargs='+', type=str,
        help="Calculate affinity for select functions with these accessions from the source "
             "provided in `--function-sources`. To get accessions from multiple sources, instead "
             "use `--select-functions-txt`.")
    group1G.add_argument(
        '--function-names', nargs='+', type=str,
        help="Calculate affinity for select functions with these names from the source provided in "
             "`--function-sources`. To get function names from multiple sources, instead use "
             "`--select-functions-txt`.")
    group1G.add_argument(
        '--select-functions-txt', metavar='FILE_PATH', type=str,
        help="Selected functions can be listed in this tab-delimited file of three columns. The "
             "first column should contain function annotation sources, the second column "
             "accessions, and the third function names. An entry in the source column is required "
             "in every row, and either an accession or name, or both, should also be in a row. "
             "The file should not have a header of column names.")
    group1G.add_argument(
        '--lax-function-sources', default=False, action='store_true',
        help="By default, without this flag, requested function annotation sources must have been "
             "run on every input (meta)genome. With this flag, it doesn't matter if any number of "
             "sources was not run on any number of input (meta)genomes.")
    group1G.add_argument(
        '--function-blacklist-txt', metavar='FILE_PATH', type=str,
        help="A single-column file of regular expressions that exclude functions from affinity "
             "calculations when patterns occur in function annotation strings. Built-in blacklists "
             "can be stored to file by running this program with the sole option, "
             "`--get-function-blacklist`. The generated file (indeed, any single-column file) can "
             "be provided with this argument. For example, if the file contains the regex, "
             "'[aA]rchaea', then functional annotations containing the substrings, 'archaea' or "
             "'Archaea', are disregarded.")
    group1G.add_argument(
        '--gene-affinity', default=False, action='store_true',
        help="Compute affinity for genes rather than functions.")
    group1G.add_argument(
        '--gene-caller-ids', nargs='+', type=int,
        help="Select genes by ID, space-separated, if using `--gene-affinity`, and genomic input "
             "from a single contigs database (not `--internal-genomes` or `--external-genomes`).")

    group1H = parser.add_argument_group(
        'SEED ASSIGNMENT',
        "It may not be possible to resolve tRNA transcripts to individual populations or genomes. "
        "tRNAs have relatively short sequences (~70-100 nt) that are often conserved across deep "
        "clades. By default, affinity calculations for functions in a genome conservatively use "
        "only those seeds with unique matches to tRNA genes in the genome, ignoring seeds that "
        "also match other genomes or unbinned contigs. Alternatively, either all or some seeds "
        "with an ambiguous source can be included in affinity calculations. "
        "`anvi-integrate-trnaseq` cannot have been run with the flag, "
        "`--unambiguous-genome-assignment`, as is the case by default, for the issue of seed "
        "ambiguity to factor into affinity calculations.")
    group1H.add_argument(
        '--seed-assignment',
        choices=['unambiguous_genome', 'unambiguous_db', 'ambiguous_all', 'ambiguous_choose'],
        type=str, default='unambiguous_genome',
        help="Control how tRNA-seq seeds assigned to tRNA genes that are not confined to a single "
             "genome -- \"ambiguous\" seeds -- affect affinity calculations. Ambiguous seeds may "
             "assigned to multiple genomes or a single genome and unbinned contigs. "
             "(1) `unambiguous_genome`: Only seeds assigned to a single INPUT (META)GENOME are "
             "used in affinity calculations. "
             "(2) `unambiguous_db`: Only seeds unambiguously assigned to each (meta)genome IN THE "
             "TRNASEQ CONTIGS DATABASE are used in affinity calculations. `anvi-integrate-trnaseq` "
             "can be run with any number of (meta)genomes, but a selection of these can be used as "
             "inputs to `anvi-compute-trnaseq-functional-affinity`. For example, `unambiguous_db` "
             "could be useful to calculate affinity for a single genome on the basis of "
             "unambiguous seeds despite multiple genomes having been integrated into the database."
             "(3): `ambiguous_all`: Both unambiguous and ambiguous seeds are used in affinity "
             "calculations. As a result, affinity calculations for different genomes will not be "
             "independent if ambiguous seeds are shared."
             "(4): `ambiguous_choose`: Try to convert ambiguous seeds to unambiguous seeds by "
             "seeking a likely genomic source for each ambiguous seed. The most likely genome is "
             "found from the summed coverages of unambiguous seeds from the competing genomes. "
             "For a most likely genome to be chosen, its summed coverage must exceed the "
             "second-highest summed coverage of a genome in every tRNA-seq sample by at least the "
             "`--min-coverage-ratio`. For example, an ambiguous seed matches genomes A, B, and C, "
             "and there are two samples, 1 and 2 (reference and non-reference). The summed "
             "coverage of unambiguous seeds assigned to genome A is 10000 in sample 1 and 5000 in "
             "sample 2; coverage for genome B, sample 1 is 1000 and genome B, sample 2 is 100; "
             "coverage for genome C, sample 1 is 500 and genome C, sample 2 is 1000. For sample 1, "
             "the ratio of highest to second-highest genome is 10000/1000 = 10, and for sample 2, "
             "the ratio is 5000/1000 = 5. In both samples, genome A has the highest total "
             "coverage. Therefore, with a `--min-coverage-ratio` â‰¤5, the ambiguous seed would be "
             "assigned to genome A for affinity calculations. With a `--min-coverage-ratio` >5, "
             "the ambiguous seed would be excluded from affinity calculations.")
    group1H.add_argument(
        '--min-coverage-ratio', metavar='FLOAT', type=float,
        default=genomictrnaseq.Affinitizer.default_min_coverage_ratio,
        help="This argument only applies to `--seed-assignment ambiguous_choose` and not any other "
             "values of `--seed-assignment`. See (4) in the `--seed-assignment` help message for "
             "details. An ambiguous seed matching multiple genomes can be salvaged for affinity "
             "calculations by assigning it to a single genome that is significantly more active "
             "than the other genomes and thereby the likely source of most of the tRNA molecules "
             "represented by the seed. The chosen genome must have at least `--min-coverage-ratio` "
             "greater summed coverage of unambiguous seeds than any of the other genomes in every "
             "tRNA-seq sample.")

    group1I = parser.add_argument_group(
        'ISOACCEPTOR PARAMETERS',
        "The calculation of affinity relies upon the abundances of tRNA isoacceptors, or groups of "
        "seeds with the same anticodon.")
    group1I.add_argument(
        '--min-coverage', metavar='INT', type=int,
        default=genomictrnaseq.Affinitizer.default_min_coverage,
        help="The coverage threshold for detection of a tRNA isoacceptor. Coverage is measured at "
             "the 3' (discriminator) nucleotide of the isoacceptor seeds. The threshold must be "
             "met in both the sample being analyzed and reference sample for the isoacceptor to "
             "contribute to affinity.")
    group1I.add_argument(
        '--exclude-unmodified-anticodons', nargs='+', type=str,
        help="Remove tRNA isoacceptors with the given unmodified anticodons from calculation of "
             "affinity. Note that this argument only handles unmodified anticodons. For example, "
             "'ACG' does not exclude 'ICG', and 'CAT' excludes tRNA-Met but not tRNA-Ile2, in "
             "which 'CAT' is modified to 'LAT' in bacteria. To exclude tRNA-Arg-ACG with the I34 "
             "modification and tRNA-Ile2, provide 'ICG LAT' with the option, "
             "`--exclude-modified-anticodons`. Exclusion of tRNAs by anticodon occurs before, and "
             "thereby affects, the `--min-isoacceptors` filter.")
    group1I.add_argument(
        '--exclude-modified-anticodons', nargs='+', type=str,
        help="Remove tRNA isoacceptors with the given modified anticodons from calculation of "
             "anticodon. Recognized modifications are wobble nucleotide I (inosine) (anticodons "
             "'INN', where 'N' is any nucleotide) and L (lysidine and, in this program, archaeal "
             "agmatidine, with the only anticodon recognized with this modification being 'LAT'). "
             "Exclusion of tRNAs by anticodon occurs before, and thereby affects, the "
             "`--min-isoacceptors` filter.")
    group1I.add_argument(
        '--min-isoacceptors', metavar='INT', type=int,
        default=genomictrnaseq.Affinitizer.default_min_isoacceptors,
        help="The minimum number of tRNA isoacceptors that need to be detected in a (meta)genomic "
             "source for affinity to be calculated. For example, say the minimum number of "
             "isoacceptors is 5, there are two internal genomes, A and B, and 10 isoacceptors pass "
             "the minimum coverage threshold in A whereas 4 isoacceptors pass the threshold in B. "
             "Affinity will be calculated for genome A but not B.")
    group1I.add_argument( # TODO: add this argument
        '--shared-isoacceptors', default=False, action='store_true',
        help="Retain isoacceptors that are shared among all of the input tRNA-seq samples (and "
             "that also pass the other isoacceptor filters). This facilitates the comparison of "
             "raw affinity data between multiple (non-reference) samples, because affinity is "
             "based on the same set of isoacceptors in each sample.")
    group1I.add_argument(
        '--decoding-weights-txt', metavar='FILE_PATH', type=str,
        help="A tab-delimited file of decoding weights, formatted identically to the file of "
             "default weights generated by running this program with the single option, "
             "`--get-default-decoding-weights`. The default weights used by this program are the "
             "s(i,j) values from Table 2 of dos Reis, Savva, and Wernisch (2004), which are used "
             "in their tRNA Adaptation Index (tAI) metric (https://doi.org/10.1093/nar/gkh834). "
             "s(i,j) means \"the selective constraint on the efficiency of the codon-anticodon "
             "coupling.\" Consistent with Table 2, weights are provided for the anticodon wobble "
             "nucleotides, A, C, G, T, I (inosine), and L (lysidine) -- these are the row index. "
             "The codon wobble nucleotides, A, C, G, and T, are the column header. A weight of 0 "
             "means that base pairing between the anticodon and codon is maximally efficient "
             "(e.g., C-G), whereas a weight of 1 means that base pairing is maximally inefficient "
             "(e.g., C-C).")

    group1J = parser.add_argument_group(
        'CODON FILTERS',
        "Functions and genes can be filtered by the number of codons that they contain, and "
        "codons can be selected for removal. The reliability or usefulness of the affinity metric "
        "is greater for functions with more analyzed codons decoded by measured tRNA-seq "
        "isoacceptors. Codon selection can be useful, for instance, in testing the effect of "
        "perturbations in the set of analyzed codons on the affinity results.")
    group1J.add_argument(
        '--min-analyzed-codons', type=int, default=0,
        help="Affinity is calculated for functions (or genes, with the flag, `--gene-affinity`) "
             "that contain at least this number of codons with corresponding tRNA-seq "
             "isoacceptors. For example, say a function contains gene sequences with 1,000 codons "
             "total, of which 300 can be decoded by isoacceptors screened for use in affinity "
             "calculations. If this argument is set to 500, then affinity would not be calculated "
             "for the function.")
    group1J.add_argument(
        '--function-min-total-codons', type=int, default=0,
        help="Affinity is calculated for functions that contain at least this number of codons "
             "total. This option can only be used with `--gene-affinity`.")
    group1J.add_argument(
        '--gene-min-total-codons', type=int, default=0,
        help="Genes must contain at least this number of codons total to contribute to affinity "
             "calculations. This option can only be used with `--gene-affinity`.")
    group1J.add_argument(
        '--exclude-codons', nargs='+', type=str,
        help="Remove the given codons from the calculation of affinity.")
    group1J.add_argument(
        '--exclude-amino-acids', nargs='+', type=str,
        help="Remove codons that decode the given amino acids from calculation of affinity.")

    group1K = parser.add_argument_group(
        'RAREFACTION STATISTICS',
        "Rarefaction of the tRNA isoacceptors used in calculation of affinity provides a means of "
        "evaluating how representative the isoacceptors are of the whole tRNA pool. The smaller "
        "the subset of isoacceptors involved in the calculation, the less reliable the metric is "
        "at evaluating the gene functions favored for translation by the tRNA pool. Affinity "
        "results that are sensitive to rarefaction indicate suggest that not enough isoacceptors "
        "were measured to achieve 'statistical significance'. Separate output files are produced "
        "for the results of rarefaction.")
    group1K.add_argument(
        '--rarefaction-limit', metavar='INT', type=int, default=0,
        help="Any positive integer for the rarefaction limit will trigger rarefaction of tRNA "
             "isoacceptors for recomputations of affinities. The rarefaction limit sets the number "
             "of randomly drawn subsamples of isoacceptors. For example, given a sample with 10 "
             "isoacceptors used in the calculation of affinity, there are 10 combinations of 1 "
             "isoacceptor that can be subsampled for recalculation with 1 isoacceptor, 45 "
             "combinations of 2 isoacceptors, ..., 252 combinations of 5 isoacceptors, ..., and 10 "
             "combinations of 9 isoacceptors. Setting a rarefaction limit of 100 would not affect "
             "any subsamples with 100 or fewer combinations, but would, for example, cause random "
             "subsampling of 100 of the 252 possible combinations of 5 isoacceptors.")

    group2 = parser.add_argument_group('INFO')
    group2.add_argument(
        '-l', '--list-samples', default=False, action='store_true',
        help="List the names of tRNA-seq samples in `seeds-specific-txt` by using this flag with "
             "the `--seeds-specific-txt` argument.")
    group2.add_argument(
        '-w', '--get-default-decoding-weights', metavar='FILE_PATH',
        help="Store a tab-delimited file of the default decoding weights used in affinity "
             "calculations. This file has the format of the input file needed for "
             "`--decoding-weights-txt`.")
    group2.add_argument(
        '-k', '--get-function-blacklist', nargs=2,
        help="Store a built-in blacklist of regular expressions that exclude functions from "
             "affinity calculations when patterns occur in function annotation strings. The first "
             "argument should be the output file path and the second argument should be the name "
             "of the built-in blacklist. The single-column output file (indeed, any single-column "
             "file) can be used with `--function-blacklist-txt`. Available named blacklists: "
             f"{', '.join(genomictrnaseq.Affinitizer.builtin_function_blacklists)}")

    args = parser.get_args(parser)

    try:
        main(args)
    except ConfigError as e:
        print(e)
        sys.exit(-1)
    except FilesNPathsError as e:
        print(e)
        sys.exit(-2)
