#!/usr/bin/env python
# -*- coding: utf-8
"""Get a block of sequence following a gene that mathces a functional annotation or HMM hit

    This program takes a contigs database, and searches for a function or HMM hit. It is useful
    when you want to study which genes are present around a gene of interest. It could be helpful
    when studying genomic loci that tend to some consereved and some variable genes.

  You want to play with it? This is how you could quickly test it:

  Downloaded the anvi'o data pack for the infant gut data, which is here:

    https://ndownloader.figshare.com/files/8252861

  Uunpack it and went into it:

    tar -zxvf INFANTGUTTUTORIAL.tar.gz && cd INFANT-GUT-TUTORIAL

  Then I run the program `anvi-export-gene-block` in the anvi'o master this way:

    anvi-export-locus -c CONTIGS.db \
                      -O OUTPUT \
                      --use-hmm \
                      --hmm-sources Campbell_et_al \
                      --search-term Ribosomal_L27 \
                      -n 24

  This will give you a fasta file OUTPUT.fa with the Ribosomal_L27 gene and the 24 genes that follow it.

  If all you want is the sequence of a gene matching a search pattern then use:
  for HMM: anvi-get-sequences-for-hmm-hits
  for functional annotations: anvi-search-functions
"""

import os
import sys
import copy
import argparse

import anvio
import anvio.db as db
import anvio.tables as t
import anvio.utils as utils
import anvio.dbops as dbops
import anvio.hmmops as hmmops
import anvio.terminal as terminal
import anvio.profiler as profiler
import anvio.filesnpaths as filesnpaths

from anvio.errors import ConfigError, FilesNPathsError
from anvio.tables.genefunctions import TableForGeneFunctions


__author__ = "Developers of anvi'o (see AUTHORS.txt)"
__copyright__ = "Copyleft 2015-2018, the Meren Lab (http://merenlab.org/)"
__credits__ = []
__license__ = "GPL 3.0"
__version__ = anvio.__version__
__maintainer__ = "A. Murat Eren"
__email__ = "a.murat.eren@gmail.com"
__requires__ = ['contigs-db']
__provides__ = ['locus-fasta']


run = terminal.Run()
progress = terminal.Progress()


class LocusSplitter:
    def __init__(self, args, r=terminal.Run(), p=terminal.Progress()):
        self.args = args
        self.run = r
        self.progress = p

        # following will be filled in during init:
        self.targets = []
        self.num_genes_list = None
        self.gene_caller_ids_of_interest = set([])

        A = lambda x: args.__dict__[x] if x in args.__dict__ else None
        self.input_contigs_db_path = A('contigs_db')
        self.num_genes = A('num_genes')
        self.search_term = A('search_term')
        self.gene_caller_ids = A('gene_caller_ids')
        self.delimiter = A('delimiter')
        self.output_dir = A('output_dir') or os.path.abspath(os.path.curdir)
        self.output_file_prefix = A('output_file_prefix') or 'the_user_provided_no_prefix_so_here_we_go_prefix'
        self.use_hmm = A('use_hmm')
        self.hmm_sources = A('hmm_sources') or set([])
        self.overwrite_output_destinations = A('overwrite_output_destinations')
        self.remove_partial_hits = A('remove_partial_hits')
        self.reverse_complement_if_necessary = (not A('never_reverse_complement')) or True
        self.include_fasta_output = True

        if A('list_hmm_sources'):
            hmmops.SequencesForHMMHits(self.input_contigs_db_path).list_available_hmm_sources()

        # unless we are in debug mode, let's keep things quiet.
        if anvio.DEBUG:
            self.run_object = terminal.Run()
        else:
            self.run_object = terminal.Run(verbose=False)


    def sanity_check(self):
        """Check sanity while straightening some input variables"""

        filesnpaths.is_output_dir_writable(self.output_dir)

        if (not (self.gene_caller_ids or self.search_term)) or (self.gene_caller_ids and self.search_term):
            raise ConfigError("You must specify exacly one of the following: --gene-caller-ids or --search-term")

        if self.use_hmm and not self.search_term:
            raise ConfigError("If you want to use HMMs to find the gene of interest that will define your locus,\
                               you must also specify a --search-term.")

        utils.is_contigs_db(self.input_contigs_db_path)

        if len(self.hmm_sources):
            self.hmm_sources = set([s.strip() for s in self.hmm_sources.split(',')])

        self.num_genes_list = [int(x) for x in args.num_genes.split(',')]
        if len(self.num_genes_list) > 2:
            raise ConfigError("The block size you provided, \"%s\", is not valid.\
                                The gene block size is defined by only one or two integers for either \
                                a block following the search match or a block preceding and following \
                                the search match respectively." % self.num_genes)

        if len(self.num_genes_list) == 1:
            self.num_genes_list = [0, self.num_genes_list[0]]

        self.run.warning(None, header="Input / Output", lc="cyan")
        self.run.info('Contigs DB', os.path.abspath(self.input_contigs_db_path))
        self.run.info('Output directory', self.output_dir)
        if ',' in self.num_genes:
            self.run.info('Genes to report', '%d genes before the matching gene, and %d that follow' % (self.num_genes_list[0], self.num_genes_list[1]))
        else:
            self.run.info('Genes to report', 'Matching gene, and %d genes after it' % (self.num_genes_list[0]))
        self.run.info('Rev-comp the locus sequence if necessary', self.reverse_complement_if_necessary)


    def init(self):
        """The whole purpose of this function is to identify which gene calls to focus"""

        self.sanity_check()

        self.run.warning(None, header="Initialization bleep bloops", lc="cyan")

        if self.gene_caller_ids:
            self.run.info('Mode', 'User-provided gene caller id(s)')

            gene_caller_ids_of_interest = list(utils.get_gene_caller_ids_from_args(self.gene_caller_ids, self.delimiter))
            self.sources = ['gene_caller_ids']
        elif self.use_hmm:
            self.run.info('Mode', 'HMM search')

            s = hmmops.SequencesForHMMHits(self.input_contigs_db_path, sources=self.hmm_sources)

            self.run.info('Search term', self.search_term, mc='green')
            self.run.info('HMM sources being used', ', '.join(s.sources))

            hmm_hits = utils.get_filtered_dict(s.hmm_hits, 'gene_name', {self.search_term})
            gene_caller_ids_of_interest = [entry['gene_callers_id'] for entry in hmm_hits.values()]

            self.targets.append('HMMs')
            self.sources = s.sources
        else:
            self.run.info('Mode', 'Function search')

            contigs_db = dbops.ContigsSuperclass(self.args, r=self.run_object)
            # use functional annotation
            contigs_db.init_functions()
            self.run.info('Search term', self.search_term, mc='green')
            self.run.info('Function calls being used', ', '.join(contigs_db.gene_function_call_sources))

            foo, search_report = contigs_db.search_for_gene_functions([args.search_term], verbose=True)
            # gene id's of genes with the searched function
            gene_caller_ids_of_interest = [i[0] for i in search_report]

            self.targets.append('functions')
            self.sources = contigs_db.gene_function_call_sources

        # Multiple sources could annotate the same gene, so make sure the list is unique
        self.gene_caller_ids_of_interest = set(gene_caller_ids_of_interest)

        if len(self.gene_caller_ids_of_interest):
            run.info('Matching genes',
                     '%d genes matched your search' % len(self.gene_caller_ids_of_interest),
                     mc='green', nl_after=1)


    def process(self, skip_init=False):
        if not skip_init:
            self.init()

        if not len(self.gene_caller_ids_of_interest):
            self.run.warning("There aren't any gene calls that match to the criteria you provided to anvi'o\
                              export locus magic. Is this yet another case of you did everything right\
                              yet anvi'o failed you? If that's the case, let us know :( This class will quietly\
                              kill this process without reporting any error since a lack of hit may be the\
                              expected outcome of some weird processes somewhere.")

        self.contigs_db = dbops.ContigsSuperclass(self.args, r=self.run_object)
        self.contigs_db.init_functions()
        counter = 1
        for gene_callers_id in self.gene_caller_ids_of_interest:
            self.run.warning(None,
                             header="Exporting locus %d of %d" % \
                                        (counter, len(self.gene_caller_ids_of_interest)),
                             nl_after=0)

            output_path_prefix = os.path.join(self.output_dir, "%s_%.4d" % (self.output_file_prefix, counter))

            self.export_locus(gene_callers_id, output_path_prefix)

            counter += 1


    def export_locus(self, gene_callers_id, output_path_prefix):
        """Takes a gene callers ID, and exports a contigs database.

           Output path prefix should be unique for every export locus call. If the prefix you provide
           looks like this:

                >>> output_path_prefix = '/path/to/dir/file_name_prefix'

           the output files will be stored as this:

                >>> '/path/to/dir/file_name_prefix.fa'
                >>> '/path/to/dir/file_name_prefix.db'

           """

        if os.path.isdir(output_path_prefix):
            raise ConfigError("Output path prefix can't be a directory name...")

        filesnpaths.is_output_file_writable(output_path_prefix + '.fa')

        if not self.contigs_db:
            self.contigs_db = dbops.ContigsSuperclass(self.args, r=self.run_object)
            self.contigs_db.init_functions()

        gene_call = self.contigs_db.genes_in_contigs_dict[gene_callers_id]
        contig_name = self.contigs_db.genes_in_contigs_dict[gene_callers_id]['contig']
        genes_in_contig_sorted = sorted(list(self.contigs_db.contig_name_to_genes[contig_name]))

        D = lambda: 1 if gene_call['direction'] == 'f' else -1
        premature, reverse_complemented = False,  False

        self.run.info("Contig name", contig_name)
        self.run.info("Contig length", self.contigs_db.contigs_basic_info[contig_name]['length'])
        self.run.info("Num genes in contig", len(genes_in_contig_sorted))
        self.run.info("Target gene call", gene_callers_id)
        self.run.info("Target gene direction", "Forward" if D() == 1 else "Reverse")

        gene_1 = gene_callers_id - self.num_genes_list[0] * D()
        gene_2 = gene_callers_id + self.num_genes_list[1] * D()
        first_gene_of_the_block = min(gene_1, gene_2)
        last_gene_of_the_block = max(gene_1, gene_2)

        self.run.info("First and last gene of the locus (raw)", "%d and %d" % (first_gene_of_the_block, last_gene_of_the_block))

        # getting the ids for the first and last genes in the contig
        last_gene_in_contig = genes_in_contig_sorted[-1][0]
        first_gene_in_contig = genes_in_contig_sorted[0][0]

        if last_gene_of_the_block > last_gene_in_contig:
            last_gene_of_the_block = last_gene_in_contig
            premature = True

        if first_gene_of_the_block < first_gene_in_contig:
            first_gene_of_the_block = first_gene_in_contig
            premature = True

        if premature and self.remove_partial_hits:
            self.run.info_single("A premature locus is found .. the current configuration says 'skip'. Skipping.", mc="red")
            return
        else:
            self.run.info_single("A premature locus is found .. the current configuration says 'whatevs'. Anvi'o will continue.", mc="yellow")

        self.run.info("First and last gene of the locus (final)", "%d and %d" % (first_gene_of_the_block, last_gene_of_the_block))

        locus_start = self.contigs_db.genes_in_contigs_dict[first_gene_of_the_block]['start']
        locus_stop = self.contigs_db.genes_in_contigs_dict[last_gene_of_the_block]['stop']

        # being a performance nerd here yes
        contig_sequence = db.DB(self.input_contigs_db_path, None, ignore_version=True) \
                            .get_some_rows_from_table(t.contig_sequences_table_name,
                                                      where_clause="contig='%s'" % contig_name)[0][1]
        locus_sequence = contig_sequence[locus_start:locus_stop]

        # here we will create a gene calls dict for genes that are specific to our locus. since we trimmed
        # the contig sequence to the locus of interest, we will have to adjust start and stop positions of
        # genes in teh gene calls dict.
        locus_gene_calls_dict = {}
        for g in range(first_gene_of_the_block, last_gene_of_the_block + 1):
            locus_gene_calls_dict[g] = copy.deepcopy(self.contigs_db.genes_in_contigs_dict[g])
            excess = self.contigs_db.genes_in_contigs_dict[first_gene_of_the_block]['start']
            locus_gene_calls_dict[g]['start'] -= excess
            locus_gene_calls_dict[g]['stop'] -= excess

        # let's get the function calls dict as well
        where_clause = "gene_callers_id in (%s)" % ', '.join(['"%d"' % g for g in range(first_gene_of_the_block, last_gene_of_the_block + 1)])
        locus_function_calls_dict  = db.DB(self.input_contigs_db_path, None, ignore_version=True) \
                                                    .get_some_rows_from_table_as_dict(t.gene_function_calls_table_name,
                                                                                      where_clause=where_clause,
                                                                                      error_if_no_data=False)

        self.run.info("Locus gene call start/stops excess (nts)", excess)

        if D() != 1 and self.reverse_complement_if_necessary:
            self.run.info("Reverse-complementing the locus", True)
            locus_sequence = utils.rev_comp(locus_sequence)
            reverse_complemented = "True"

            # FIXME: locus gene calls dict must be updated here:
            #   turn every f -> r, every r -> f
            #   reset gene caller id
            #   adjust gene start stops
            #   gene caller ids will have to be updated in locus_gene_function_calls_dict too
        else:
            reverse_complemented = "False"

        # report a stupid FASTA file.
        if self.include_fasta_output:
            fasta_file_path = output_path_prefix + ".fa"

            self.run.info("Output FASTA file", fasta_file_path)
            with open(fasta_file_path, 'w') as f:
                locus_header = contig_name + ' ' + \
                               '|'.join(['target:%s' % ','.join(self.targets),
                                         'sources:%s' % ','.join(self.sources),
                                         'query:%s' % self.search_term or 'None',
                                         'hit_contig:%s' % contig_name,
                                         'hit_gene_callers_id:%s' % str(gene_callers_id),
                                         'project_name:%s' % self.contigs_db.a_meta['project_name'].replace(' ', '_').replace("'", '_').replace('"', '_'),
                                         'locus:%s,%s' % (str(first_gene_of_the_block), str(last_gene_of_the_block)),
                                         'nt_positions_in_contig:%s:%s' % (str(locus_start), str(locus_stop)),
                                         'premature:%s' % str(premature),
                                         'reverse_complemented:%s' % str(reverse_complemented)])

                f.write('>%s\n' % locus_header)
                f.write('%s\n' % locus_sequence)

        # report a fancy anvi'o contigs database
        self.store_locus_as_contigs_db(contig_name,
                                       locus_sequence,
                                       locus_gene_calls_dict,
                                       locus_function_calls_dict,
                                       output_path_prefix)


    def store_locus_as_contigs_db(self, contig_name, sequence, gene_calls, function_calls, output_path_prefix):
        locus_output_db_path = output_path_prefix + ".db"
        locus_sequence_fasta = output_path_prefix + "_sequence.fa"
        locus_external_gene_calls = output_path_prefix + "_external_gene_calls.txt"

        profile_output_dir = output_path_prefix + '-PROFILE'
        if os.path.exists(profile_output_dir):
            if self.overwrite_output_destinations:
                filesnpaths.shutil.rmtree(profile_output_dir)
            else:
                raise ConfigError("The directory %s exists, which kinda messes things up here. Either remove\
                                   it manually, or use the flag  --overwrite-output-destinations so anvi'o can\
                                   do it for you.")

        if filesnpaths.is_file_exists(locus_output_db_path, dont_raise=True):
            if self.overwrite_output_destinations:
                os.remove(locus_output_db_path)
            else:
                raise ConfigError("There is already a contigs database at the output file path :( Either remove it first,\
                                   or use the --overwrite-output-destinations flag to give anvi'o full authority to wipe\
                                   your disk.")

        with open(locus_sequence_fasta, 'w') as f:
            f.write('>%s\n' % contig_name)
            f.write('%s\n' % sequence)

        # store external gene calls
        headers = ['gene_callers_id', 'contig', 'start', 'stop', 'direction', 'partial', 'source', 'version']
        utils.store_dict_as_TAB_delimited_file(gene_calls, locus_external_gene_calls, headers=headers)

        args = argparse.Namespace(contigs_fasta=locus_sequence_fasta,
                                  project_name='project_name',
                                  split_length=sys.maxsize,
                                  kmer_size=4,
                                  external_gene_calls=locus_external_gene_calls)
        dbops.ContigsDatabase(locus_output_db_path, run=self.run_object).create(args)

        gene_function_calls_table = TableForGeneFunctions(locus_output_db_path, run=self.run_object)
        gene_function_calls_table.create(function_calls)


        # generate a blank profile
        args = argparse.Namespace(blank_profile=True,
                                  contigs_db=locus_output_db_path,
                                  skip_hierarchical_clustering=False,
                                  output_dir=profile_output_dir,
                                  sample_name=os.path.basename(output_path_prefix))
        profiler.BAMProfiler(args, r=self.run_object)._run()

        if anvio.DEBUG:
            self.run.info_single("Temp output files were kept for inspection due to --debug")
        else:
            os.remove(locus_sequence_fasta)
            os.remove(locus_external_gene_calls)


if __name__ == '__main__':
    parser = argparse.ArgumentParser(description="Search for a function or HMM hit and for each matching gene \
                                                    get the sequence including a block of genes the around the match.\
                                                    The output will be written to a fasta file (or multiple files, see\
                                                    --separate-fasta option below. The headers of the sequences in the\
                                                    fasta file hold some information about the gene.)")

    groupA = parser.add_argument_group('Essential INPUT')
    groupA.add_argument(*anvio.A('contigs-db'), **anvio.K('contigs-db'))
    groupA.add_argument('-n', '--num-genes',type=str, help='For each match (to the function, or HMM that was searched) a sequence which includes \
                            a block of genes will be saved. The block could include either genes only in the forward direction of the gene (defined \
                            according to the direction of transcription of the gene) or reverse or both. \
                            If you wish to get both direction use a comma (no spaces) to define the block \
                            For example, \"-n 4,5\" will give you four genes before and five genes after. \
                            Whereas, \"-n 5\" will give you five genes after (in addition to the gene that matched). \
                            To get only genes preceeding the match use \"-n 5,0\". \
                            If the number of genes requested exceeds the length of the contig, then the output \
                            will include the sequence until the end of the contig.', required=True)
    groupB =  parser.add_argument_group('Additional essential INPUT - OPTION 1', "Search according to either HMM or functional annotations")
    groupB.add_argument('-s', '--search-term', help='Search term.')
    groupC =  parser.add_argument_group('Additional essential INPUT - OPTION 2', "Search specific gene id's")
    groupC.add_argument(*anvio.A('gene-caller-ids'), **anvio.K('gene-caller-ids'))
    groupC.add_argument(*anvio.A('delimiter'), **anvio.K('delimiter'))

    groupD = parser.add_argument_group('THE OUTPUT', "Where should the output go. It will be one FASTA file with all matches \
                                       or one FASTA per match (see --separate-fasta)") 
    groupD.add_argument(*anvio.A('output-dir'), **anvio.K('output-dir'))
    groupD.add_argument(*anvio.A('output-file-prefix'), **anvio.K('output-file-prefix', {'required': True}))

    groupE = parser.add_argument_group('ADDITIONAL STUFF', "Flags and parameters you can set according to your need")
    groupE.add_argument('--separate-fasta', default = False, action='store_true', help='Split each match to a separate FASTA file.')
    groupE.add_argument('--use-hmm', default = False, action='store_true', help='Use HMM hits instead of functional annotations. \
                            If you choose this option, you must also say which HMM source to use.')
    groupE.add_argument(*anvio.A('hmm-sources'), **anvio.K('hmm-sources'))
    groupE.add_argument(*anvio.A('list-hmm-sources'), **anvio.K('list-hmm-sources'))
    groupE.add_argument(*anvio.A('overwrite-output-destinations'), **anvio.K('overwrite-output-destinations'))
    groupE.add_argument(*anvio.A('remove-partial-hits'), **anvio.K('remove-partial-hits'))
    groupE.add_argument(*anvio.A('never-reverse-complement'), **anvio.K('never-reverse-complement'))

    args = anvio.get_args(parser)

    try:
        locus_splitter = LocusSplitter(args)
        locus_splitter.process()
    except ConfigError as e:
        print(e)
        sys.exit(-1)
    except FilesNPathsError as e:
        print(e)
        sys.exit(-1)
