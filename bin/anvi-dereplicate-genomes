#!/usr/bin/env python
# -*- coding: utf-8
"""A script to remove replicated genomes from a list of internal and external genome databases or fasta files"""


import os
import sys
import shutil
import argparse

import anvio
import anvio.utils as utils
import anvio.terminal as terminal
import anvio.filesnpaths as filesnpaths
import anvio.genomedistance as genomedistance

from anvio.errors import ConfigError, FilesNPathsError
import anvio.errors

__author__ = "Developers of anvi'o (see AUTHORS.txt)"
__copyright__ = "Copyleft 2015-2019, the Meren Lab (http://merenlab.org/)"
__credits__ = []
__license__ = "GPL 3.0"
__version__ = anvio.__version__
__maintainer__ = "Mahmoud Yousef"
__email__ = "mahmoudyousef@uchicago.edu"
__requires__ = ['external-genomes', 'internal-genomes', 'contigs-fasta']
__provides__ = ['contigs-fasta']
__description__ = ("Identify redundant (highly similar) genomes. Export non-redundant genomes as fasta files")

run = terminal.Run()


class Dereplicate:
    def __init__(self, args):
        self.args = args

        A = lambda x, t: t(args.__dict__[x]) if x in args.__dict__ else None
        null = lambda x: x

        # input
        self.internal_genomes = A('internal_genomes', null)
        self.external_genomes = A('external_genomes', null)
        self.fasta_text_file = A('fasta_text_file', null)
        self.ani_dir = A('ani_dir', null)
        self.mash_dir = A('mash_dir', null)
        # mode
        self.program_name = A('program', null) or 'pyANI'
        self.representative_method = A('representative_method', null)
        # pyANI specific
        self.min_alignment_fraction = A('min_alignment_fraction', null)
        self.significant_alignment_length = A('significant_alignment_length', null)
        self.min_percent_identity = A('min_percent_identity', null)
        self.use_full_percent_identity = A('use_full_percent_identity', null)
        # sourmash specific
        self.min_mash_distance = A('min_mash_distance', null)
        self.distance_threshold = A('distance_threshold', null)
        # output
        self.provide_fasta_txt = A('provide_fasta_txt', null)
        self.output_dir = A('output_dir', null)
        self.just_do_it = A('just_do_it', null)

        self.import_previous_results = False

        self.determine_run_mode()
        self.run_sanity_checks()
        self.distance_metric_name = self.get_distance_metric_name()


    def get_distance_metric_name(self):
        if self.program_name in ['pyANI']:
            self.distance_metric_name = 'percentage_identity' if not self.use_full_percent_identity else 'full_percentage_identity'
        elif self.program_name in ['sourmash']:
            self.distance_metric_name = 'mash_distance'


    def is_genome_names_compatible_with_distance_matrix(self, distance_matrix, genome_names):
        matrix_names = distance_matrix.keys()
        for name in genome_names:
            if name not in matrix_names:
                raise ConfigError("At least one of your genomes (one being %s) does not appear in the distance matrix. This could be due\
                                   to many different reasons. Probably, the distance matrix that was generated or imported is\
                                   incomplete or has been changed/corrupted by this point. If you imported your results with --ani-dir\
                                   or --mash-dir, we recommend re-running with standard inputs. See `INPUT OPTIONS` within the help menu" % name)


    def determine_run_mode(self):
        if not any([self.program_name, self.ani_dir, self.mash_dir]):
            raise ConfigError("Anvi'o could not determine how you want to dereplicate\
                              your genomes. Please take a close look at your parameters: either --program needs to be\
                              set, or an importable directory (e.g. --ani-dir, --mash-dir, etc) needs to be provided.")

        if self.program_name not in ['pyANI', 'sourmash']:
            raise ConfigError("Anvi'o is impressed by your dedication to dereplicate your genomes through %s, but\
                              %s is not compatible with `anvi-dereplicate-genomes`. Anvi'o can only work with pyANI\
                              and sourmash separately." % (self.program_name, self.program_name))

        if self.ani_dir and self.mash_dir:
            raise ConfigError("Anvi'o cannot currently dereplicate using both ANI and mash distance results at\
                              the same time. Please pick one to use for dereplication")

        if self.ani_dir or self.mash_dir:
            self.import_previous_results = True

        if self.ani_dir and not self.program_name not in ['pyANI']:
            run.warning("You provided a pre-existing directory of ANI results (--ani-dir), but also provided a program\
                        name ('%s') that was not compatible with ANI. Anvi'o knows that you want to use the pre-existing\
                        results, so she cunningly ignores this slip-up." % self.program_name)
            self.program_name = 'pyANI'

        if self.mash_dir and not self.program_name not in ['sourmash']:
            run.warning("You provided a pre-existing directory of mash results (--mash-dir), but also provided a program\
                        name ('%s') that was not compatible with mash. Anvi'o knows that you want to use the pre-existing\
                        results, so she cunningly ignores this slip-up." % self.program_name)
            self.program_name = 'sourmash'


    def run_sanity_checks(self):
        if self.import_previous_results:
            run.warning("You chose to work with an already existing results folder. Please keep in mind that you\
                         are now burdened with the responsibility of knowing what parameters you used to generate\
                         these results.")

        if self.min_alignment_fraction < 0 or self.min_alignment_fraction > 1:
            if self.program_name == "pyANI":
                raise ConfigError("Alignment coverage is a value between 0 and 1. Your cutoff alignment coverage\
                                  value of %.2f doesn't fit in these boundaries" % self.min_alignment_fraction)

        if self.min_mash_distance < 0 or self.min_mash_distance > 1:
            if self.program_name == "sourmash":
                raise ConfigError("A mash distance of 0 implies no similarity between two genomes. A mash distance\
                                 of 1 indicates the two genomes are exactly the same. Anvi'o doesn't understand your\
                                 threshold value of %.2f" % self.min_mash_distance)

        if self.distance_threshold < 0 or self.distance_threshold > 1:
            raise ConfigError("When anvi'o collapses %s's output into a distance matrix, all values are reported as\
                              distances between 0 and 1. %.2f can't be used to determine redundant genomes"\
                              % (self.program_name, self.distance_threshold))

        if self.representative_method == "Qscore" and self.fasta_text_file:
            self.representative_method = "distance"
            run.warning("You asked anvi'o to choose representative genomes by Qscore, but also provided a fasta text\
                        file. Fasta files do not include estimates on completion and redundancy. Anvi'o will switch\
                        over to 'distance'")


    def init_genome_distance(self):
        if self.program_name == "pyANI":
            self.distance = genomedistance.ANI(self.args)
        else:
            assert self.program_name == "sourmash", "Fatal error in self.program_name assertion in initialization. Please inform the developers."
            self.distance = genomedistance.SourMash(self.args)


    def get_distance_matrix(self):
        distance_matrix = self.import_distance_matrix() if self.import_previous_results else self.calculate_distance_matrix()
        self.is_genome_names_compatible_with_distance_matrix(self.distance_matrix, self.distance.genome_names)
        run.info('Number of genomes considered', len(distance_matrix))

        return distance_matrix


    def calculate_distance_matrix(self):
        temp_dir = self.distance.get_fasta_sequences_dir()
        self.distance.process(temp_dir)

        distance_matrix = self.distance.results[self.distance_metric_name]

        run.info('%s distance metric' % self.program_name, 'calculated')

        if anvio.DEBUG:
            import json
            for report in self.distance.results:
                run.warning(None, header=report)
                print(json.dumps(self.distance.results[report], indent=2))

        return distance_matrix


    def import_distance_matrix(self):
        dir_name, dir_path = ('--ani-dir', self.ani_dir) if self.program_name in ['pyANI'] else ('--mash-dir', self.mash_dir)

        necessary_reports = [self.distance_metric_name] + (['alignment_coverage'] if self.program_name in ['pyANI'] else [])

        if filesnpaths.is_dir_empty(dir_path):
            raise ConfigError("The %s you provided is empty. What kind of game are you playing?" % dir_name)
        files_in_dir = os.listdir(self.ani_dir)

        for report in necessary_reports:
            report_name = report + ".txt"
            matching_filepaths = [f for f in files_in_dir if report_name in f]

            if len(matching_filepaths) > 1:
                raise ConfigError("Your results directory contains multiple text files for the matrix %s.\
                                  Please clean up your directory and make sure that only one text file of this\
                                  report exists" % report)
            elif len(matching_filepaths) == 0:
                raise ConfigError("Your results directory does not have a text file for the report %s.\
                                  Anvi'o cannot dereplicate genomes from prevous results without this report" % report)

            self.distance.results[report] = utils.get_TAB_delimited_file_as_dictionary(os.path.join(dir_path, matching_filepaths[0]))

        # self.distance does not know genome_names because these results are imported. we populate it manually here
        self.distance.genome_names = list(self.distance.results['alignment_coverage'].keys())

        run.info('%s results directory imported from' % self.program_name, dir_path)

        return self.distance.results[self.distance_metric_name]


    def main(self):
        run.info('Run mode', self.program_name)

        filesnpaths.check_output_directory(self.output_dir, ok_if_exists=False)
        os.mkdir(self.output_dir)

        # inits self.distance
        self.init_genome_distance()

        self.distance_matrix = self.get_distance_matrix()


        nonredundant_genome_names = self.distance.remove_redundant_genomes(self.distance_matrix)
        num_redundant = len(all_genome_names) - len(nonredundant_genome_names)
        run.info('Number of redundant genomes', num_redundant)
        run.info('Final number of dereplicated genomes', len(nonredundant_genome_names))

        if anvio.DEBUG:
            import json
            all_groups = self.distance.retrieve_genome_groups(nonredundant_genome_names)
            for name in all_groups.keys():
                run.warning(None, header=name)
                print(json.dumps(all_groups[name], indent=2))

        if not self.import_previous_results:
            hashes = self.distance.rehash_names(nonredundant_genome_names)
            utils.move_fasta_files_from_fasta_dir(temp_dir, hashes, self.output_dir, fasta_txt=self.provide_fasta_txt)

        run.info_single('Dereplicated fasta files stored in %s' % self.output_dir, nl_before=1)
        if self.provide_fasta_txt:
                run.info_single('FASTA text file `dereplcated-fasta.txt` stored in %s' % self.output_dir, nl_before=1)

        if anvio.DEBUG:
            run.warning("The temp directory, %s, is kept. Please don't forget to clean it up\
                         later" % temp_dir, header="Debug")
        elif not self.import_previous_results:
            run.info_single('Cleaning up the temp directory (you can use `--debug` if you would\
                             like to keep it for testing purposes)', nl_before=1, nl_after=1)
            shutil.rmtree(temp_dir)
            temp_dir = None


    def process(self):
        self.main()


if __name__ == '__main__':
    parser = argparse.ArgumentParser(description=__description__)

    groupA = parser.add_argument_group('INPUT OPTIONS', "Tell anvi'o what you want.")
    groupA.add_argument(*anvio.A('internal-genomes'), **anvio.K('internal-genomes'))
    groupA.add_argument(*anvio.A('external-genomes'), **anvio.K('external-genomes'))
    groupA.add_argument(*anvio.A('fasta-text-file'), **anvio.K('fasta-text-file'))

    groupD = parser.add_argument_group('Import results', "Alternatively, if you have previous ANI or mash distance\
                                        computations on your genomes, you can import the result directory here to use. Please note\
                                        that file names must remain unchanged for anvi'o to find them")
    groupD.add_argument('--ani-dir', type=str, metavar='PATH', help="You can import the directory created by `anvi-compute-ani`\
                        and use it for dereplication")
    # FIXME anvi-compute-mash-distance does not exist. Ideally, we rename anvi-compute-ani to
    # anvi-compute-genome-distance and can calculate either ANI or mash
    groupD.add_argument('--mash-dir', type=str, metavar='PATH', help="You can import the directory created by `anvi-compute-mash-distance`\
                        and use it for dereplication")

    groupB = parser.add_argument_group('OUTPUT OPTIONS', "Tell anvi'o where to store your results.")
    groupB.add_argument(*anvio.A('output-dir'), **anvio.K('output-dir', {'required': True}))
    groupB.add_argument('--provide-fasta-txt', default=False, action='store_true', help="If you would like anvi'o to provide\
                        a fasta.txt file with all of the dereplicated fasta filepaths, you can use this option\
                        to tell it to do so. The file will be called 'dereplicated-fasta.txt' and will be located\
                        in the output directory.")

    groupC = parser.add_argument_group('Program', "Tell anvi'o which similarity program to run.")
    groupC.add_argument('--program', type=str, help="Tell anvi'o which program to run to process genome similarity.\
                        You can either use pyANI for ANI calculations or sourmash for mash distance. You must have\
                        the necessary binary in path for the program you choose.",\
                        choices=['pyANI','sourmash'])

    groupE = parser.add_argument_group('pyANI Settings', "Tell anvi'o to tell pyANI what method you wish to use and what settings to set.\
                        Only if `--program` is set to `pyANI`")
    groupE.add_argument('--method', default='ANIb', type=str, help="Method for pyANI. The default is %(default)s.\
                         You must have the necessary binary in path for whichever method you choose. According to\
                         the pyANI help for v0.2.7 at https://github.com/widdowquinn/pyani, the method 'ANIm' uses\
                         MUMmer (NUCmer) to align the input sequences. 'ANIb' uses BLASTN+ to align 1020nt fragments\
                         of the input sequences. 'ANIblastall': uses the legacy BLASTN to align 1020nt fragments\
                         Finally, 'TETRA': calculates tetranucleotide frequencies of each input sequence",\
                         choices=['ANIm', 'ANIb', 'ANIblastall', 'TETRA'])
    groupE.add_argument(*anvio.A('min-alignment-fraction'), **anvio.K('min-alignment-fraction', params_dict={'default':0.25}))
    groupE.add_argument(*anvio.A('significant-alignment-length'), **anvio.K('significant-alignment-length'))
    groupE.add_argument(*anvio.A('use-full-percent-identity'), **anvio.K('use-full-percent-identity'))
    groupE.add_argument(*anvio.A('min-percent-identity'), **anvio.K('min-percent-identity', params_dict = {'default': 0.0,
                        'help': "When you set a value, anvi'o will go through the ANI results, and set\
                                 percent identity scores between genomes to 0 if *either* of the percent\
                                 identity values fall below this value. The default value is %(default)g."}))

    groupF = parser.add_argument_group('sourmash settings', "Tell anvi'o to run sourmash with specific settings. Only\
                        if `--program` is set to `sourmash`")
    groupF.add_argument('--kmer-size', type=int, default=51, metavar='INT', help="Set the k-mer size for mash\
                        distance checks. The sourmash default is 51, which is the default option. For\
                        relatively shorter or longer genomes, you may want to decrease or increase this size\
                        respectively")
    groupF.add_argument('--scale', type=int, default=1000, metavar='INT', help='Set the compression ratio for\
                        fasta signature file computations. The default is 1000. Smaller ratios decrease sensitivity,\
                        while larger ratios will lead to large fasta signatures.')
    groupF.add_argument('--min-mash-distance', type=float, default=0.30, help="You can tell anvi'o to\
                        automatically consider genomes as non-redundant if they have a mash distance\
                        below a specific value. The default is 0.3")

    groupG = parser.add_argument_group('Dereplication Parameters', "Some parameters to guide your dereplication")
    groupG.add_argument('--distance-threshold', type=float, default=0.97, help="For dereplication, anvi'o collapses\
                        all results into a single distance matrix and refers to it for dereplication. Using\
                        this parameter, you can define the threshold for declaring genomes redundant. The default\
                        is 0.97")
    groupG.add_argument('--representative-method', default='distance', type=str, help="After genomes are grouped into\
                        redundancy clusters, you can define how anvi'o picks the representative genome from the\
                        cluster. 'Qscore' computes the genome with the highest completion and lowest redundancy as\
                        the representative. 'length' returns the longest genome. 'distance' returns the genome with\
                        the highest average distance to everything in the cluster. The default is %(default)s",\
                        choices=['Qscore', 'length', 'distance'])

    groupH = parser.add_argument_group('OTHER IMPORTANT STUFF', "Yes. You're almost done.")
    groupH.add_argument(*anvio.A('num-threads'), **anvio.K('num-threads'))
    groupH.add_argument(*anvio.A('just-do-it'), **anvio.K('just-do-it'))
    groupH.add_argument(*anvio.A('log-file'), **anvio.K('log-file'))

    args = anvio.get_args(parser)

    try:
        Dereplicate(args).process()
    except ConfigError as e:
        print(e)
        sys.exit(-1)
    except FilesNPathsError as e:
        print(e)
        sys.exit(-1)
