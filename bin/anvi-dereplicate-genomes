#!/usr/bin/env python
# -*- coding: utf-8
"""A script to remove replicated genomes from a list of internal and external genome databases or fasta files"""


import os
import sys
import shutil
import argparse

import anvio
import anvio.utils as utils
import anvio.terminal as terminal
import anvio.filesnpaths as filesnpaths
import anvio.genomedistance as genomedistance

from anvio.errors import ConfigError, FilesNPathsError
import anvio.errors

__author__ = "Developers of anvi'o (see AUTHORS.txt)"
__copyright__ = "Copyleft 2015-2019, the Meren Lab (http://merenlab.org/)"
__credits__ = []
__license__ = "GPL 3.0"
__version__ = anvio.__version__
__maintainer__ = "Mahmoud Yousef"
__email__ = "mahmoudyousef@uchicago.edu"
__requires__ = ['external-genomes', 'internal-genomes', 'contigs-fasta']
__provides__ = ['contigs-fasta']
__description__ = ("Identify redundant (highly similar) genomes. Export non-redundant genomes as fasta files")

run = terminal.Run()


def is_compatible(results, genome_names):
    matrix_names = results.keys()
    for name in genome_names:
        if name not in matrix_names:
            raise ConfigError("At least one of your genomes (one being %s) does not appear in the results matrix. This could be due\
                               to many different reasons. Probably, the results matrix that was generated or imported is\
                               incomplete or has been changed/corrupted by this point. If you imported your results with --ani-dir\
                               or --mash-dir, we recommend re-running with standard inputs. See `INPUT OPTIONS` within the help menu" % name)


def determine_run_mode(args):
    if args.ani_dir and args.mash_dir:
        raise ConfigError("Anvi'o cannot currently dereplicate using both ANI and mash distance results at\
                          the same time. Please pick one to use for dereplication")
    if args.program:
        choice = args.program
        if choice != "pyANI" and choice != "sourmash":
            raise ConfigError("Anvi'o is impressed by your dedication to dereplicate your genomes through %s, but\
                             %s is not compatible with `anvi-dereplicate-genomes`. Anvi'o can only work with pyANI\
                             and sourmash separately." % (args.program, args.program))

        if choice == "pyANI" and args.mash_dir:
            raise ConfigError("You asked anvi'o to use pyANI to dereplicate your genomes but provided a mash results\
                              directory. Anvi'o doesn't know how to proceed")

        elif choice == "sourmash" and args.ani_dir:
            raise ConfigError("You asked anvi'o to use sourmash to dereplicate your genomes but provided an ani results\
                              directory. Anvi'o doesn't know how to proceed")

        if choice == "pyANI" and args.ani_dir:
            return ("pyANI", True)
        elif choice == "pyANI":
            return ("pyANI", False)
        elif choice == "sourmash" and args.mash_dir:
            return ("sourmash", True)
        else:
            return ("sourmash", False)

    else:
        if args.ani_dir:
            return ("pyANI", True)
        elif args.mash_dir:
            return ("sourmash", True)
        else:
            raise ConfigError("Anvi'o could not determine whether you want to run pyANI or sourmash to dereplicate\
                              your genomes. Please take a close look at your parameters: either --program needs to be\
                              set, or an importable ANI or mash directory needs to be provided")


def run_sanity_checks(args, choice):
    mode = choice[0]
    if args.min_alignment_fraction < 0 or args.min_alignment_fraction > 1:
        if mode == "pyANI":
            raise ConfigError("Alignment coverage is a value between 0 and 1. Your cutoff alignment coverage\
                              value of %.2f doesn't fit in these boundaries" % args.min_alignment_fraction)

    if args.min_mash_distance < 0 or args.min_mash_distance > 1:
        if mode == "sourmash":
            raise ConfigError("A mash distance of 0 implies no similarity between two genomes. A mash distance\
                             of 1 indicates the two genomes are exactly the same. Anvi'o doesn't understand your\
                             threshold value of %.2f" % args.min_mash_distance)

    if args.distance_threshold < 0 or args.distance_threshold > 1:
        raise ConfigError("When anvi'o collapses %s's output into a distance matrix, all values are reported as\
                          distances between 0 and 1. %.2f can't be used to determine redundant genomes"\
                          % (mode, args.distance_threshold))

    if args.representative_method == "Qscore" and args.fasta_text_file:
        if args.just_do_it:
            run.warning("You asked anvi'o to choose representative genomes by Qscore, but also provided a fasta text\
                        file. Fasta files do not include estimates on completion and redundancy. So be it. Be warned that\
                        the representative genomes you receive may not be biologically significant in any way.")
        else:
            run.warning("You asked anvi'o to choose representative genomes by Qscore, but also provided a fasta text\
                        file. Fasta files do not include estimates on completion and redundancy. Anvi'o will switch\
                        over to 'distance'")
        args.representative_method = "distance"


def main(args, choice):
    mode, prev = choice
    run.info('Run mode', mode)

    filesnpaths.check_output_directory(args.output_dir, ok_if_exists=False)
    os.mkdir(args.output_dir)

    if mode == "pyANI":
        program = genomedistance.ANI(args)
    else:
        assert mode == "sourmash", "Fatal error in mode assertion in initialization. Please inform the developers."
        program = genomedistance.SourMash(args)

    temp_dir = program.get_fasta_sequences_dir()

    if not prev:
        program.process(temp_dir)

        if mode == "pyANI":
            distance_matrix = program.get_proper_percent_identity(program.results)

            run.info('pyANI process', 'completed')

            if anvio.DEBUG:
                import json
                for report in results:
                    run.warning(None, header=report)
                    print(json.dumps(results[report], indent=2))
        else:
            assert mode == "sourmash", "Fatal error in mode assertion in generating results. Please inform the developers."

            distance_matrix = program.results

            run.info('sourmash process', 'completed')

            if anvio.DEBUG:
                import json
                run.warning(None,header="Mash Distances")
                print(json.dumps(results, indent=2))

    else:
        if mode == "pyANI":
            if filesnpaths.is_dir_empty(args.ani_dir):
                raise ConfigError("The --ani-dir you provided is empty. What kind of game are you playing?")

            necessary_reports = ['alignment_coverage', 'percentage_identity']
            for report in necessary_reports:
                report_name = report + ".txt"
                matching_filepaths = [f for f in files_in_dir if report_name in f]

                if len(matching_filepaths) > 1:
                    raise ConfigError("Your ANI results directory contains multiple text files for the matrix %s.\
                                     Please clean up your directory and make sure that only one text file of this\
                                     report exists" % report)
                elif len(matching_filepaths) == 0:
                    raise ConfigError("Your ANI results directory does not have a text file for the report %s.\
                                      Anvi'o cannot dereplicate genomes through pyANI without this report" % report)

                program.results[report] = utils.get_TAB_delimited_file_as_dictionary(os.path.join(args.ani_dir, matching_filepaths[0]))

            distance_matrix = program.get_proper_percent_identity(program.results)

            run.info('PyANI results directory imported', args.ani_dir)
        else:
            assert mode == "sourmash", "Fatal error in mode assertion in importing file. Please inform the devlopers."

            distance_matrix = utils.get_TAB_delimited_file_as_dictionary(os.path.join(args.mash_dir, "distance_matrix.txt"))

            run.info('sourmash results directory imported', args.mash_dir)

    genomes = program.retrieve_genome_names()
    is_compatible(distance_matrix, genomes)
    run.info('Number of genomes retrieved', len(genomes))

    genome_names = program.remove_redundant_genomes(distance_matrix)
    num_redundant = len(genomes) - len(genome_names)
    run.info('Number of redundant genomes', num_redundant)
    run.info('Final number of dereplicated genomes', len(genome_names))

    if anvio.DEBUG:
        import json
        all_groups = program.retrieve_genome_groups(genome_names)
        for name in all_groups.keys():
            run.warning(None, header=name)
            print(json.dumps(all_groups[name], indent=2))

    hashes = program.rehash_names(genome_names)
    utils.move_fasta_files_from_fasta_dir(temp_dir, hashes, args.output_dir, fasta_txt=args.provide_fasta_txt)
    run.info_single('Dereplicated fasta files stored in %s' % args.output_dir)
    if args.provide_fasta_txt:
            run.info_single('FASTA text file `dereplcated-fasta.txt` stored in %s' % args.output_dir)

    if anvio.DEBUG:
        run.warning("The temp directory, %s, is kept. Please don't forget to clean it up\
                     later" % temp_dir, header="Debug")
    else:
        run.info_single('Cleaning up the temp directory (you can use `--debug` if you would\
                         like to keep it for testing purposes)', nl_before=1, nl_after=1)
        shutil.rmtree(temp_dir)
        temp_dir = None


if __name__ == '__main__':
    parser = argparse.ArgumentParser(description=__description__)

    groupA = parser.add_argument_group('INPUT OPTIONS', "Tell anvi'o what you want.")
    groupA.add_argument(*anvio.A('internal-genomes'), **anvio.K('internal-genomes'))
    groupA.add_argument(*anvio.A('external-genomes'), **anvio.K('external-genomes'))
    groupA.add_argument(*anvio.A('fasta-text-file'), **anvio.K('fasta-text-file'))

    groupB = parser.add_argument_group('OUTPUT OPTIONS', "Tell anvi'o where to store your results.")
    groupB.add_argument(*anvio.A('output-dir'), **anvio.K('output-dir', {'required': True }))
    groupB.add_argument('--provide-fasta-txt', default=False, action='store_true', help="If you would like anvi'o to provide\
                        a -fasta.txt file with all of the dereplicated fasta file outputs, you can use this option\
                        to tell it to do so. The file will be called 'dereplicated-fasta.txt' and will be located\
                        in the output directory.")

    groupC = parser.add_argument_group('Program', "Tell anvi'o which similarity program to run.")
    groupC.add_argument('--program', type=str, help="Tell anvi'o which program to run to process genome similarity.\
                        You can either use pyANI for ANI calculations or sourmash for mash distance. You must have\
                        the necessary binary in path for the program you choose.",\
                        choices=['pyANI','sourmash'])

    groupD = parser.add_argument_group('Import results', "Alternatively, if you have previous ANI or mash distance\
                                        computations on your genomes, you can import the result directory here to use. Please note\
                                        that file names must remain unchanged for anvi'o to find them")
    groupD.add_argument('--ani-dir', type=str, metavar='PATH', help="You can import the directory created by `anvi-compute-ani`\
                        and use it for dereplication")

    # FIXME anvi-compute-mash-distance does not exist. Ideally, we rename anvi-compute-ani to
    # anvi-compute-genome-distance and can calculate either ANI or mash
    groupD.add_argument('--mash-dir', type=str, metavar='PATH', help="You can import the directory created by `anvi-compute-mash-distance`\
                        and use it for dereplication")

    groupE = parser.add_argument_group('pyANI Settings', "Tell anvi'o to tell pyANI what method you wish to use and what settings to set.\
                        Only if `--program` is set to `pyANI`")
    groupE.add_argument('--method', default='ANIb', type=str, help="Method for pyANI. The default is %(default)s.\
                         You must have the necessary binary in path for whichever method you choose. According to\
                         the pyANI help for v0.2.7 at https://github.com/widdowquinn/pyani, the method 'ANIm' uses\
                         MUMmer (NUCmer) to align the input sequences. 'ANIb' uses BLASTN+ to align 1020nt fragments\
                         of the input sequences. 'ANIblastall': uses the legacy BLASTN to align 1020nt fragments\
                         Finally, 'TETRA': calculates tetranucleotide frequencies of each input sequence",\
                         choices=['ANIm', 'ANIb', 'ANIblastall', 'TETRA'])
    groupE.add_argument(*anvio.A('min-alignment-fraction'), **anvio.K('min-alignment-fraction', params_dict={'default':0.25}))
    groupE.add_argument(*anvio.A('significant-alignment-length'), **anvio.K('significant-alignment-length'))

    groupF = parser.add_argument_group('sourmash settings', "Tell anvi'o to run sourmash with specific settings. Only\
                        if `--program` is set to `sourmash`")
    groupF.add_argument('--kmer-size', type=int, default=51, metavar='INT', help="Set the k-mer size for mash\
                        distance checks. sourmash recommends a size of 51, which is the default option. For\
                        relatively shorter or longer genomes, you may want to decrease or increase this size\
                        respectively")
    groupF.add_argument('--scale', type=int, default=1000, metavar='INT', help='Set the compression ratio for\
                        fasta signature file computations. The default is 1000. Smaller ratios decrease sensitivity,\
                        while larger ratios will lead to large fasta signatures.')
    groupF.add_argument('--min-mash-distance', type=float, default=0.30, help="You can tell anvi'o to\
                        automatically consider genomes as non-redundant if they have a mash distance\
                        below a specific value. The default is 0.3")

    groupG = parser.add_argument_group('Dereplication Parameters', "Some parameters to guide your dereplication")
    groupG.add_argument('--distance-threshold', type=float, default=0.97, help="For dereplication, anvi'o collapses\
                        all results into a single distance matrix and refers to it for dereplication. Using\
                        this parameter, you can define the threshold for declaring genomes redundant. The default\
                        is 0.97")
    groupG.add_argument('--representative-method', default='distance', type=str, help="After genomes are grouped into\
                        redundancy clusters, you can define how anvi'o picks the representative genome from the\
                        cluster. 'Qscore' computes the genome with the highest completion and lowest redundancy as\
                        the representative. 'length' returns the longest genome. 'distance' returns the genome with\
                        the highest average distance to everything in the cluster. The default is %(default)s",\
                        choices=['Qscore', 'length', 'distance'])

    groupH = parser.add_argument_group('OTHER IMPORTANT STUFF', "Yes. You're almost done.")
    groupH.add_argument(*anvio.A('num-threads'), **anvio.K('num-threads'))
    groupH.add_argument(*anvio.A('just-do-it'), **anvio.K('just-do-it'))
    groupH.add_argument(*anvio.A('log-file'), **anvio.K('log-file'))

    args = anvio.get_args(parser)

    try:
        mode = determine_run_mode(args)
        run_sanity_checks(args, mode)
        main(args, mode)
    except ConfigError as e:
        print(e)
        sys.exit(-1)
    except FilesNPathsError as e:
        print(e)
        sys.exit(-1)
