#!/usr/bin/env python
# coding: utf-8

import os
import sys
import subprocess

from Bio import SeqIO, SearchIO
from Bio.SeqRecord import SeqRecord

import anvio
import anvio.terminal as terminal
import anvio.filesnpaths as filesnpaths

from anvio.argparse import ArgumentParser
from anvio.errors import ConfigError, FilesNPathsError

__copyright__ = "Copyleft 2015-2024, The Anvi'o Project (http://anvio.org/)"
__credits__ = []
__license__ = "GPL 3.0"
__version__ = anvio.__version__
__authors__ = ['ahenoch']
__requires__ = []
__provides__ = []
__description__ = "Reorient contigs based on the longest complete genome presend in the given folder"

run = terminal.Run()

def letterFrequency(fileName, letter):
    # modified from https://www.geeksforgeeks.org/count-the-number-of-times-a-letter-appears-in-a-text-file-in-python/
    file = open(fileName, 'r')
    text = file.read()
    frequency = text.count(letter)
    length = len(text)
    return(frequency, length)

def main(args):

    input_dir = args.input_dir
    filesnpaths.is_output_dir_writable(input_dir)

    reference_fasta = None
    length_max = 0
    length_curr = 0
    fasta_files = []

    #find FASTA files in the directory
    for fasta_file in os.listdir(dir_path):

        fasta_file = dir_path + '/' + file_path

        if os.path.isfile(fasta_file):

            try:
                filesnpaths.is_file_fasta_formatted(fasta_file)

                fasta_files += [file_path]

                frequency, length_curr = letterFrequency(fasta_file, '>')

                if frequency == 1:
                    reference_fasta = fasta_file if length_curr > length_max else reference_fasta
                    length_max = length_curr if length_curr > length_max else length_max

            except FilesNPathsError:
                run.info_single(f"Skipping {file_path} not formatted as fasta.")

        else:
            run.info_single(f"Skipping {file_path} not a file.")

    if not reference_fasta:
        raise ConfigError(f"Unfortunately no fasta file in your folder is a complete genome.")

    for file_path in fasta_files:

        fasta_file = dir_path + '/' + file_path
        blast_result_file = dir_path + '/' + file_path.split('.')[0] + '_blast'

        if fasta_file != reference_fasta:

            pass_arg=["blastn", "-query", reference_fasta, "-out", blast_result_file, "-outfmt", "5", "-subject", fasta_file]
            blast_result_txt = subprocess.run(pass_arg, text=True, capture_output=True)
            qresult = SearchIO.read(blast_result_file, 'blast-xml')
            fasta_entry = list(SeqIO.parse(fasta_file, "fasta"))

            with open(fasta_file, "w+") as output_handle:

                for contig in qresult:

                    original_record = [entry for entry in fasta_entry if entry.id == contig.id][0]

                    original_record_sequence = original_record.seq
                    reversed_record_sequence = original_record.seq.reverse_complement()

                    reoriented_record_hit = contig[0].hit.seq.replace("-", "")
                    reoriented_record_sequence = ""

                    if reoriented_record_hit in original_record_sequence:
                        reoriented_record_sequence = original_record_sequence
                    elif reoriented_record_hit in reversed_record_sequence:
                        reoriented_record_sequence = reversed_record_sequence
                    else:
                        run.info_single(f"This case is not yet implemented.")

                    if reoriented_record_sequence:

                        reoriented_record = SeqRecord(
                            reoriented_record_sequence,
                            id=original_record.id,
                            name=original_record.name,
                            description=original_record.description,
                        )

                        SeqIO.write(reoriented_record, output_handle, "fasta")

                    else:
                        run.info_single(f"No output possible, the fastas do not align :(")


if __name__ == '__main__':

    parser = ArgumentParser(description=__description__)
    groupA = parser.add_argument_group('Folder containing the fasta files')
    groupA.add_argument(*anvio.A('input-dir'), **anvio.K('input-dir', {'help': "Path for the directory "
                "that contains the FASTA files of interest. Anvi'o will take into consideration any file "
                "in this directory that has any of the following extensions: '.fa', '.fasta', '.fna', "
                "'.ffn', and '.faa'."}))

    args = parser.get_args(parser)

    try:
        main(args)
    except ConfigError as e:
        print(e)
        sys.exit(-1)
    except FilesNPathsError as e:
        print(e)
        sys.exit(-2)
