#!/usr/bin/env python
# -*- coding: utf-8
"""Get codon or amino acid frequency statistics from genomes, genes, and functions."""

import os
import sys
import argparse

from collections import Counter

import anvio
import anvio.tables as t
import anvio.utils as utils
import anvio.dbops as dbops
import anvio.terminal as terminal
import anvio.constants as constants
import anvio.codonusage as codonusage
import anvio.filesnpaths as filesnpaths
import anvio.interactive as interactive

from anvio.dbinfo import DBInfo
from anvio.argparse import ArgumentParser
from anvio.interactive import AdHocRunGenerator
from anvio.bottleroutes import BottleApplication
from anvio.errors import ConfigError, FilesNPathsError
from anvio.utils import get_TAB_delimited_file_as_dictionary


__copyright__ = "Copyleft 2015-2024, The Anvi'o Project (http://anvio.org/)"
__credits__ = []
__license__ = "GPL 3.0"
__version__ = anvio.__version__
__authors__ = ['meren', 'semiller10']
__requires__ = ['contigs-db', 'profile-db', 'collection', 'bin']
__provides__ = ['interactive', 'svg']
__description__ = ("Display codon frequency statistics across genes in a given genome")

run = terminal.Run()

def main(args):
    """Prepare arguments to get codon frequencies."""
    # Store the coding dictionary in `args`
    args.codon_to_amino_acid = codonusage.get_custom_encodings(args.encodings_txt)

    if args.include_amino_acids and args.exclude_amino_acids:
        raise ConfigError(
            "Either `--include-amino-acids` or `--exclude-amino-acids` should be given, not both.")

    # Amino acids to exclude are the complement of amino acids to include.
    if args.include_amino_acids:
        args.exclude_amino_acids = []
        for amino_acid in constants.amino_acids:
            if amino_acid in args.include_amino_acids:
                continue
            else:
                args.exclude_amino_acids.append(amino_acid)

    # determine the output directory to write the frequency view data
    output_dir = filesnpaths.get_temp_directory_path()
    run.info("Output file directory", output_dir)

    single_genome_codon_usage = codonusage.SingleGenomeCodonUsage(args, run=terminal.Run(verbose=False))

    # get the raw frequency data to learn about total number of codons and amino acids across the genome
    output_file = os.path.join(output_dir, 'raw-frequency-data.txt')
    raw_frequency_df = single_genome_codon_usage.get_frequencies()
    total_counts_per_codon = raw_frequency_df.sum().to_dict()
    total_counts_per_aa = Counter({})
    for codon in total_counts_per_codon:
        aa = constants.codon_to_AA[codon]
        total_counts_per_aa[aa] += total_counts_per_codon[codon]

    # now get the frequency data considering user parameters
    output_file = os.path.join(output_dir, 'condon-frequency-data.txt')

    args.pansequence_min_amino_acids = [int(args.pansequence_min_amino_acids[0]),
                                        float(args.pansequence_min_amino_acids[1])]

    frequency_df = single_genome_codon_usage.get_frequencies(
        return_amino_acids=args.return_amino_acids,
        gene_caller_ids=args.gene_caller_ids,
        relative=args.relative,
        synonymous=args.synonymous,
        sum_genes=args.sum,
        average_genes=args.average,
        gene_min_codons=args.gene_min_codons,
        min_codon_filter=args.min_codon_filter,
        drop_amino_acids=args.exclude_amino_acids,
        sequence_min_amino_acids=args.sequence_min_amino_acids,
        pansequence_min_amino_acids=args.pansequence_min_amino_acids,
        infinity_to_zero=args.infinity_to_zero)

    # Write output tables.
    frequency_df.to_csv(output_file, sep='\t')

    # get back the data dict with a prefix for visualization purposes.
    data_dict = get_TAB_delimited_file_as_dictionary(output_file, key_prefix='g_')

    # get functions
    contigs_db = dbops.ContigsDatabase(args.contigs_db)
    functions_dict = contigs_db.db.get_table_as_dict(t.gene_function_calls_table_name)
    functions_dict = utils.get_filtered_dict(functions_dict, 'source', set(['KOfam']))
    gene_calls_dict = contigs_db.db.get_table_as_dict(t.genes_in_contigs_table_name)
    contigs_db.disconnect()

    gene_caller_id_to_kofam = {}
    for entry in list(functions_dict.values()):
        if entry['accession']:
            gene_caller_id_to_kofam[entry['gene_callers_id']] = entry['accession'].split('!!!')[0]

    # setup additional items data. remember, at this point every gene caller id has a prefix `g_`
    # to avoid downstream issues, so one of the ways to ensure we keep track of gene calls is to
    # have an additional data layer with the actual anvi'o gene caller ID information
    additional_items_data = {}
    ribosomal_proteins = ["K02946", "K02906", "K02926", "K02930", "K02892", "K02886", "K02965", "K02890", "K02982", "K02878", "K02904", "K02961", "K02874", "K02895", "K02987", "K02931", "K02954", "K02994", "K02933", "K02912", "K02885", "K02881", "K02988", "K02907", "K02876", "K02919", "K02952", "K02948", "K02986", "K02883", "K02879", "K02871", "K02996", "K02992", "K02950", "K07590", "K02936", "K02979", "K02896", "K02935", "K02869", "K02864", "K02863", "K02867", "K02967", "K02956", "K02916", "K02887", "K02914", "K02939", "K02963", "K02990", "K02888", "K02899", "K02902", "K02913", "K02911", "K02909", "K02897", "K02959", "K02884", "K02968", "K02945", "K02970"]
    for gene_call_with_prefix in data_dict:
        gene_call = int(gene_call_with_prefix.lstrip('g_'))

        if gene_call in gene_caller_id_to_kofam:
            if gene_caller_id_to_kofam[gene_call] in ribosomal_proteins:
                d = {'gene_call': gene_call, 'function_category': 'Ribosomal Proteins'}
            else:
                d = {'gene_call': gene_call, 'function_category': None}
        else:
            d = {'gene_call': gene_call, 'function_category': None}

        d['length'] = gene_calls_dict[gene_call]['stop'] - gene_calls_dict[gene_call]['start']
        d['direction'] = gene_calls_dict[gene_call]['direction']

        additional_items_data[gene_call_with_prefix] = d

    # learn about our codons
    codons_in_data_dict = next(iter(data_dict.values())).keys()
    codons_to_display = [codon for codon in constants.coding_codons if codon in codons_in_data_dict]

    # setup additional layer data
    additional_layers_data = {}

    # start with codon to AA
    for codon in codons_to_display:
        additional_layers_data[codon] = {'amino_acid': constants.codon_to_AA[codon],
                                         'codon_frequency': total_counts_per_codon[codon],
                                         'amino_acid_frequency': total_counts_per_aa[constants.codon_to_AA[codon]]}

    g = AdHocRunGenerator(output_dir, data_dict, None, codons_to_display, linkage='ward', run=terminal.Run(verbose=False))
    g.delete_output_directory_if_exists = True
    g.generate()
    g.add_items_additional_data(additional_items_data, ['gene_call', 'length', 'direction', 'function_category'])
    g.add_layers_additional_data(additional_layers_data, ['amino_acid', 'codon_frequency', 'amino_acid_frequency'])
    g.add_state('default', state_path=os.path.join(os.path.dirname(anvio.__file__), 'data/mini-states/display-codons.json'))

    J = lambda x: os.path.join(output_dir, x)
    args_for_interactive = argparse.Namespace(profile_db=J('profile.db'),
                                              manual_mode=True,
                                              fasta_file=None,
                                              view_data=J('view.txt'),
                                              tree=J('tree.txt'),
                                              ip_address=args.ip_address,
                                              title=f"Codon Composition for {DBInfo(args.contigs_db).project_name}",
                                              port_number=args.port_number,
                                              browser_path=args.browser_path,
                                              read_only=args.read_only,
                                              server_only=args.server_only,
                                              password_protected=args.password_protected,
                                              user_server_shutdown=args.user_server_shutdown)

    # go interactive
    d = interactive.Interactive(args_for_interactive)
    args.port_number = utils.get_port_num(args.port_number, args.ip_address, run=run)
    app = BottleApplication(d)
    app.run_application(args.ip_address, args.port_number)


if __name__ == '__main__':
    parser = ArgumentParser(description=__description__)

    groupA = parser.add_argument_group('GENOME', "Show us where to find the genome to Display codons "
        "across genes in a single genome. It could also be a bin stored in a collection.")
    groupA.add_argument(*anvio.A('contigs-db'), **anvio.K('contigs-db', {'required': False}))
    groupA.add_argument(*anvio.A('profile-db'), **anvio.K('profile-db', {'required': False}))
    groupA.add_argument(*anvio.A('collection-name'), **anvio.K('collection-name'))
    groupA.add_argument(*anvio.A('bin-id'), **anvio.K('bin-id'))
    groupA.add_argument(
        '--gene-caller-ids', type=int, nargs='+', help="Select genes by ID, space-separated.")

    groupC = parser.add_argument_group('OUTPUT PARAMETERS')
    groupC.add_argument('--infinity-to-zero', default=False, action='store_true', help="Replace "
             "NA (empty) values in output with 0.0. NA occurs with `--synonymous` when all "
             "codons for an amino acid are absent in a gene or function, resulting in 0/0, "
             "reported as NA. Use with caution.")

    groupD = parser.add_argument_group('FREQUENCY STATISTICS', "How should codon frequencies be computed.")
    groupD.add_argument(*anvio.A('relative'), **anvio.K('relative'))
    groupD.add_argument(*anvio.A('synonymous'), **anvio.K('synonymous'))
    groupD.add_argument(*anvio.A('return-amino-acids'), **anvio.K('return-amino-acids'))
    groupD.add_argument(*anvio.A('encodings-txt'), **anvio.K('encodings-txt'))
    groupD.add_argument(*anvio.A('sum'), **anvio.K('sum'))
    groupD.add_argument(*anvio.A('average'), **anvio.K('average'))

    groupF = parser.add_argument_group('FILTER GENES, FUNCTIONS, CODONS',
        "Genes/functions can be filtered by the number of codons they contain, e.g., ignore genes "
        "shorter than 300 codons. Codons can be selected a priori, e.g., ignore Ala codons, or "
        "rarer codons can be excluded, e.g., ignore amino acids that are decoded by ≤3 codons in "
        "≥90%% of genes. Filters can improve the statistical utility of codon relative frequency "
        "data.")
    groupF.add_argument(*anvio.A('gene-min-codons'), **anvio.K('gene-min-codons'))
    groupF.add_argument(*anvio.A('function-min-codons'), **anvio.K('function-min-codons'))
    groupF.add_argument(*anvio.A('exclude-amino-acids'), **anvio.K('exclude-amino-acids'))
    groupF.add_argument(*anvio.A('include-amino-acids'), **anvio.K('include-amino-acids'))
    groupF.add_argument(*anvio.A('sequence-min-amino-acids'), **anvio.K('sequence-min-amino-acids'))
    groupF.add_argument(*anvio.A('pansequence-min-amino-acids'), **anvio.K('pansequence-min-amino-acids'))
    groupF.add_argument(*anvio.A('min-codon-filter'), **anvio.K('min-codon-filter'))

    groupX = parser.add_argument_group('SERVER CONFIGURATION', "For power users.")
    groupX.add_argument(*anvio.A('ip-address'), **anvio.K('ip-address'))
    groupX.add_argument(*anvio.A('port-number'), **anvio.K('port-number'))
    groupX.add_argument(*anvio.A('browser-path'), **anvio.K('browser-path'))
    groupX.add_argument(*anvio.A('read-only'), **anvio.K('read-only'))
    groupX.add_argument(*anvio.A('server-only'), **anvio.K('server-only'))
    groupX.add_argument(*anvio.A('password-protected'), **anvio.K('password-protected'))
    groupX.add_argument(*anvio.A('user-server-shutdown'), **anvio.K('user-server-shutdown'))

    args = parser.get_args(parser)

    try:
        main(args)
    except ConfigError as e:
        print(e)
        sys.exit(-1)
    except FilesNPathsError as e:
        print(e)
        sys.exit(-2)
