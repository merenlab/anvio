#!/usr/bin/env python
# -*- coding: utf-8
"""
DEVELOPMENT NOTES:
==================

- Should be able to import pre-existing table that is the output of anvi-gen-variability-profile
- Question: Should an imported table be allowed to be filtered by the params in parameter group
  "EXTRAS"? If so, this should also be a capability in anvi-gen-variability-profile: to re-filter a
  variability table.

-"""

import sys
import os
import argparse

import anvio

from anvio.errors import ConfigError, FilesNPathsError
from anvio.structureops import mess_around
from anvio.variabilityops import variability_engines
from anvio.drivers import MODELLER
import Bio.PDB as PDB

import anvio
import anvio.dbops as dbops
import anvio.terminal as terminal
import anvio.filesnpaths as filesnpaths

import anvio.fastalib as u

__author__ = "A. Murat Eren"
__copyright__ = "Copyright 2015, The anvio Project"
__credits__ = []
__license__ = "GPL 3.0"
__version__ = anvio.__version__
__maintainer__ = "A. Murat Eren"
__email__ = "a.murat.eren@gmail.com"

run = terminal.Run()
progress = terminal.Progress()

def main(args):

    # parameters that must be defined but not accessible to user
    vars(args)["engine"] = "AA"

    # generate variability pandas DataFrame object
    variability_engine = variability_engines[args.engine](args)
    variability_engine.process()

    # save report if output-file provided
    if args.output_file:
        variability_engine.report()

    ########################################################
    ########################################################

    ############# DEFINE GENES OF INTEREST ##################

    # get list of genes of interest
    table = variability_engine.data
    genes = [str(gene) for gene in list(table["corresponding_gene_call"].unique()[-3:])]

    ############# CREATE TEMP PATH FOR PRE-MODELLER ##################

    tmp_dir = filesnpaths.get_temp_directory_path()

    ############# WRITE FASTA OF ALL GENES ###########
    """
    The ideal workflow will be to rewrite export_aa_sequences_from_contigs_db to accept
    a list of genes of interest. I will then loop through the genes of interest and 
    write single-gene FASTA files. Currently, I parse through a FASTA of ALL genes and 
    ignore those that are not in the genes of interest.
    """
    # create fasta file of all genes in database
    progress.new('GETTING GENE SEQUENCES')
    progress.update("Exporting AA gene sequences from contigs database...")
    all_genes_fasta_path = os.path.join(tmp_dir, "all_genes.fasta")
    dbops.export_aa_sequences_from_contigs_db(args.contigs_db, all_genes_fasta_path)
    progress.end()

    ######## LOOP THROUGH EACH GENE IN FASTA ########

    fasta = u.SequenceSource(all_genes_fasta_path)

    while next(fasta):

        # do nothing if not gene of interest
        if fasta.id not in genes:
            continue

        # define temp file with format <gene_callers_id>.fasta
        single_gene_fasta_path = os.path.join(tmp_dir, "{}.fasta".format(fasta.id))

        # write single gene fasta
        single_gene_fasta = u.FastaOutput(single_gene_fasta_path)
        single_gene_fasta.write_id(fasta.id)
        single_gene_fasta.write_seq(fasta.seq, split = False)

        # close fasta
        single_gene_fasta.close()

        ############### INITIALIZE MODELLER DRIVER ############

        mod = MODELLER.MODELLER(single_gene_fasta_path, directory=tmp_dir)
        mod.fasta_to_pir()
        mod.close()


if __name__ == '__main__':
    parser = argparse.ArgumentParser(description="Map variable positions onto protein structures. If you do\
                                                  not have structures of the proteins you're interested in, this\
                                                  function is not for you :(.")

    groupT = parser.add_argument_group('STRUCTURES', 'Declaring relevant protein structures (.pdb files)')
    groupD = parser.add_argument_group('DATABASES', 'Declaring relevant anvi\'o databases. First things first.')
    groupS = parser.add_argument_group('SPLITS', 'Declaring relevant splits for the analysis. There are two\
                                                  ways to do it. One, you can give a file path with split names,\
                                                  or, as an alternative, you can provide a collection id with a\
                                                  bin name.')
    groupO = parser.add_argument_group('OUTPUT', 'Output file and output style')
    groupE = parser.add_argument_group('EXTRAS', 'Parameters that will help you to do a very precise analysis.\
                                                  If you declare nothing from this bunch, you will get "everything"\
                                                  to play with, which is not necessarily a good thing...')

    groupT.add_argument('--structures', '-S', required=True, help=\
    """
    Path of the folder which all .pdb files are stored in.
    """)

    groupS.add_argument(*anvio.A('splits-of-interest'), **anvio.K('splits-of-interest'))
    groupS.add_argument(*anvio.A('collection-name'), **anvio.K('collection-name'))
    groupS.add_argument(*anvio.A('bin-id'), **anvio.K('bin-id'))
    groupD.add_argument(*anvio.A('profile-db'), **anvio.K('profile-db'))
    groupD.add_argument(*anvio.A('contigs-db'), **anvio.K('contigs-db'))
    groupO.add_argument(*anvio.A('output-file'), **anvio.K('output-file', {'default': None}))
    groupO.add_argument(*anvio.A('samples-of-interest'), **anvio.K('samples-of-interest'))
    groupO.add_argument(*anvio.A('quince-mode'), **anvio.K('quince-mode'))
    groupO.add_argument(*anvio.A('include-contig-names'), **anvio.K('include-contig-names'))
    groupO.add_argument(*anvio.A('include-split-names'), **anvio.K('include-split-names'))
    groupE.add_argument(*anvio.A('num-positions-from-each-split'), **anvio.K('num-positions-from-each-split'))
    groupE.add_argument(*anvio.A('min-scatter'), **anvio.K('min-scatter'))
    groupE.add_argument(*anvio.A('min-coverage-in-each-sample'), **anvio.K('min-coverage-in-each-sample'))
    groupE.add_argument(*anvio.A('min-departure-from-reference'), **anvio.K('min-departure-from-reference'))
    groupE.add_argument(*anvio.A('max-departure-from-reference'), **anvio.K('max-departure-from-reference'))
    groupE.add_argument(*anvio.A('min-departure-from-consensus'), **anvio.K('min-departure-from-consensus'))
    groupE.add_argument(*anvio.A('max-departure-from-consensus'), **anvio.K('max-departure-from-consensus'))
    groupE.add_argument(*anvio.A('min-occurrence-of-variable-positions'), **anvio.K('min-occurrence-of-variable-positions'))
    groupE.add_argument(*anvio.A('genes-of-interest'), **anvio.K('genes-of-interest'))

    args = parser.parse_args()

    try:
        main(args)
    except ConfigError as e:
        print(e)
        sys.exit(1)
    except FilesNPathsError as e:
        print(e)
        sys.exit(2)
