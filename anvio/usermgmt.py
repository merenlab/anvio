# -*- coding: utf-8
"""
    user management db operations.
"""

import os
import sqlite3

import copy
import crypt
import string
import random
import hashlib
import shutil

import time
from datetime import date

import anvio
import anvio.terminal as terminal
import anvio.interactive as interactive
import anvio.filesnpaths as filesnpaths

from anvio.errors import ConfigError


__author__ = "Tobias Paczian"
__copyright__ = "Copyright 2015, The anvio Project"
__credits__ = []
__license__ = "GPL 3.0"
__version__ = anvio.__version__
__maintainer__ = "Tobias Paczian"
__email__ = "tobiaspaczian@googlemail.com"
__status__ = "Development"


run = terminal.Run()
progress = terminal.Progress()


class UserMGMT:
    def __init__(self, args, client_version, ignore_version=False, mailer = None,
                 run = run, progress = progress):
        self.args = args
        self.run = run
        self.progress = progress

        self.users_data_dir = args.users_data_dir
        self.users_db_path = os.path.join(self.users_data_dir, 'USERS.db')
        self.mailer = mailer

        self.version = None

        if not os.path.exists(self.users_data_dir):
            self.run.warning('A new directory is being initiated to hold users database ...')
            filesnpaths.gen_output_directory(self.users_data_dir)
            self.create_self(client_version)

        if not os.path.exists(self.users_db_path):
            self.run.warning('An empty users database is being initiated in an already existing directory ...')
            self.create_self(client_version)

        self.conn = sqlite3.connect(self.users_db_path)
        self.conn.text_factory = str
        self.conn.row_factory = dict_factory

        self.cursor = self.conn.cursor()

        self.version = self.get_version()

        if str(self.version) != str(client_version) and not ignore_version:
            raise ConfigError, "It seems the database '%s' was generated when your client was at version %s,\
                                however, your client now is at version %s. Which means this database file\
                                cannot be used with this client anymore and needs to be upgraded to the\
                                version %s :/"\
                                        % (self.users_db_path, self.version, client_version, client_version)


    def get_version(self):
        try:
            return self.get_meta_value('version')
        except Exception, e:
            raise ConfigError, "%s does not seem to be a database generated by anvi'o :/ Here is the original\
                                complaint: '%s'," % (self.users_db_path, e)


    def create_self(self, client_version):
        conn = sqlite3.connect(self.users_db_path)
        cursor = conn.cursor()

        cursor.execute("CREATE TABLE self (key TEXT PRIMARY KEY, value TEXT)")
        cursor.execute("CREATE TABLE users (login TEXT PRIMARY KEY, firstname TEXT, lastname TEXT, email TEXT, password TEXT, path TEXT, token TEXT, accepted INTEGER, project TEXT, affiliation TEXT, ip TEXT, clearance TEXT, date TEXT)")
        cursor.execute("CREATE TABLE projects (name TEXT PRIMARY KEY, path TEXT, user TEXT)")
        cursor.execute("CREATE TABLE views (name TEXT PRIMARY KEY, project TEXT, public INTEGER, token TEXT)")
        cursor.execute("INSERT INTO self VALUES(?,?)", ('version', client_version,))

        conn.commit()
        conn.close()


    def remove_meta_key_value_pair(self, key):
        p = (key, )
        self.cursor.execute("DELETE FROM self WHERE key=?", p)
        self.conn.commit()


    def get_meta_value(self, key):
        p = (key, )
        response = self.cursor.execute("SELECT value FROM self WHERE key=?", p)
        row = response.fetchone()
        
        if not row:
            raise ConfigError, "A value for '%s' does not seem to be set in table 'self'." % key

        val = row['value']

        if type(val) == type(None):
            return None

        try:
            val = int(val)
        except ValueError:
            pass

        return val

    def disconnect(self):
        self.conn.close()


    ######################################
    # USERS
    ######################################
    def create_user(self, firstname, lastname, email, login, password, affiliation, ip, clearance="user"):
        # check if all arguments were passed
        if not (firstname and lastname and email and login and password):
            return (False, "You must pass a firstname, lastname, email login and password to create a user")

        # check if the login name is already taken
        p = (login, )
        response = self.cursor.execute('SELECT login FROM users WHERE login=?', p)
        row = response.fetchone()

        if row:
            return (False, "Login '%s' is already taken." % login)

        # check if the email is already taken
        p = (email, )
        response = self.cursor.execute('SELECT email FROM users WHERE email=?', p)
        row = response.fetchone()

        if row:
            return (False, "Email '%s' is already taken." % email)
        
        # calculate path
        path = hashlib.md5(login).hexdigest()

        # crypt password
        password = crypt.crypt(password, ''.join(random.choice(string.ascii_letters + string.digits) for _ in range(2)))

        # generate token
        token = ''.join(random.choice(string.ascii_letters + string.digits) for _ in range(32))

        # set accepted to 'false'
        accepted = 0

        # get the current date
        entrydate = date.fromtimestamp(time.time()).isoformat()
        
        # create the user entry in the DB
        p = (firstname, lastname, email, login, password, path, token, accepted, affiliation, ip, clearance, entrydate, )
        response = self.cursor.execute("INSERT INTO users (firstname, lastname, email, login, password, path, token, accepted, affiliation, ip, clearance, date) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)", p)
        self.conn.commit()

        # send the user a mail to verify the email account
        anvioURL = "http://%s/" % self.args.ip_address if self.args.ip_address else "localhost";
        messageSubject = "anvio account request"
        messageText = "You have requested an account for anvio.\n\nClick the following link to activate your account:\n\n"+anvioURL+"confirm?code="+token+"&login="+login;

        self.mailer.send(email, messageSubject, messageText)
        
        return (True, "User request created")


    def get_user_for_email(self, email):
        if not email:
            raise ConfigError, "You must pass an email to retrieve a user entry"

        p = (email, )
        response = self.cursor.execute("SELECT * FROM users WHERE email=?", p)
        user = response.fetchone()

        if user:
            # check if the user has a project set
            user = self.get_user_projects(user)
        
        return user
    

    def get_user_for_login(self, login):
        if not login:
            raise ConfigError, "You must pass a login to retrieve a user entry"

        p = (login, )
        response = self.cursor.execute("SELECT * FROM users WHERE login=?", p)
        user = response.fetchone()

        if user:
            # check if the user has a project set
            user = self.get_user_projects(user)
        
        return user


    def get_user_for_token(self, token):
        if not token:
            raise ConfigError, "You must pass a token to retrieve a user entry"

        p = (token, )
        response = self.cursor.execute("SELECT * FROM users WHERE token=?", p)
        user = response.fetchone()

        if user:
            # check if the user has a project set
            user = self.get_user_projects(user)
            return (True, user)
        else:
            return (False, 'invalid token')


    def reset_password(self, user):
        if not user:
            raise ConfigError, "You must pass a user to reset a password"

        # generate random password
        password = ''.join(random.choice(string.ascii_letters + string.digits) for _ in range(8))

        # crypt password
        cpassword = crypt.crypt(password, ''.join(random.choice(string.ascii_letters + string.digits) for _ in range(2)))

        login = user['login']
        
        # update the user entry in the DB
        p = (cpassword, login)
        response = self.cursor.execute("UPDATE users SET password=? WHERE login=?", p)
        self.conn.commit()

        # send the user a mail with the new password
        email = user['email']
        messageSubject = "anvio password reset"
        messageText = "You have requested your password for your anvi'o account to be reset.\n\nYour new password is:\n\n"+password+"\n\nPlease log into anvi'o with these credentials and change your password.";

        self.mailer.send(email, messageSubject, messageText)

        return True

    def change_password(self, user, password):
        if not user:
            raise ConfigError, "You must pass a user to change a password"

        # crypt password
        cpassword = crypt.crypt(password, ''.join(random.choice(string.ascii_letters + string.digits) for _ in range(2)))

        login = user['login']
        
        # update the user entry in the DB
        p = (cpassword, login)
        response = self.cursor.execute("UPDATE users SET password=? WHERE login=?", p)
        self.conn.commit()

        return True
        
    def accept_user(self, login, token):
        if not (login and token):
            raise ConfigError, "You must pass a login and a token to accept a user"

        p = (login, )
        response = self.cursor.execute("SELECT token, path FROM users WHERE login=?", p)
        row = response.fetchone()

        if not row:
            return(False, "No user found for login '%s'." % login)

        val = row['token']

        if val == token:
            self.cursor.execute("UPDATE users SET accepted=1 WHERE login=?", p)
            self.conn.commit()

            # create the user directory
            path = self.users_data_dir + '/userdata/' + row['path']
            if not os.path.exists(path):
                os.makedirs(path)

            return (True, "User confirmed")
        else:
            return (False, "Invalid token for user '%s'." % login)


    def login_user(self, login, password):
        if not (login and password):
            raise ConfigError, "You must pass a login and a token to accept a user"

        # get the user from the db
        user = self.get_user_for_login(login)

        if not user:
            return (False, "login or password invalid")

        # verify the password
        valid = crypt.crypt(password, user['password']) == user['password']

        if not valid:
            return (False, "login or password invalid")

        # generate a new token
        token = ''.join(random.choice(string.ascii_letters + string.digits) for _ in range(32))
        token = login + token
        p = (token, login, )
        self.cursor.execute("UPDATE users SET token=? WHERE login=?", p)
        self.conn.commit()

        # check if the user has a project set
        user = self.get_user_projects(user)

        # set the user token
        user["token"] = token

        return (True, user)

    def logout_user(self, login):
        if not login:
            raise ConfigError, "You must pass a login to log out a user"

        # get the user from the db
        user = self.get_user_for_login(login)

        if not user:
            return (False, "user not found")

        # remove the token from the DB
        p = (login, )
        self.cursor.execute("UPDATE users SET token='' WHERE login=?", p)
        self.conn.commit()

        return (True, None)

    ######################################
    # PROJECTS
    ######################################
    
    def create_project(self, login, pname):
        if not login:
            raise ConfigError, "You must pass a login to create a project"
        if not pname:
            raise ConfigError, "You must pass a project name to create a project"
        user = self.get_user_for_login(login)

        if not user:
            return (False, "Could not find a user for login %s" % login)

        # create a path name for the project
        ppath = hashlib.md5(pname).hexdigest()
        path = self.users_data_dir + '/userdata/' + user["path"] + '/' + ppath

        if not os.path.exists(path):
            os.makedirs(path)
            p = (pname, ppath, login, )
            response = self.cursor.execute("INSERT INTO projects (name, path, user) VALUES (?, ?, ?)", p)
            self.conn.commit()
            return (True, { "name": pname, "path": ppath, "user": login })
        else:
            return (False, 'You already have a project of that name')

    def get_project(self, user, projectname):
        if not user:
            raise ConfigError, "You must pass a user to retrieve a project"

        if not projectname:
            raise ConfigError, "You must pass a project name"

        p = (user, projectname, )
        response = self.cursor.execute("SELECT * FROM projects WHERE user=? AND name=?", p)
        project = response.fetchone()

        return project
        
    def get_user_projects(self, user):
        if not user:
            raise ConfigError, "You must pass a user to retrieve their current project"

        if user['project']:
            p = (user['login'], user['project'], )
            response = self.cursor.execute("SELECT * FROM projects WHERE user=? AND name=?", p)
            project = response.fetchone()
            if project:
                user['project'] = project['name']
                user['project_path'] = project['path']


        # get all user project names
        p = (user['login'], )
        response = self.cursor.execute("SELECT name FROM projects WHERE user=?", p)
        projects = response.fetchall()
        ps = []
        for row in projects:
            ps.append({ "name": row['name'], "views": []})
            p = (row['name'], )
            response = self.cursor.execute("SELECT name, public, token FROM views WHERE project=?", p)
            views = response.fetchall()
            for r in views:
                ps[len(ps) - 1]['views'].append({"name": r['name'], "public": r['public'], "token": r['token']});
        user['projects'] = ps
        
        return user

    def set_project(self, login, pname):
        if not login:
            raise ConfigError, "You must pass a login to create a project"
        if not pname:
            raise ConfigError, "You must pass a project name to create a project"
        user = self.get_user_for_login(login)

        if not user:
            return (False, "Could not find a user for login %s" % login)
        
        p = (login, pname, )
        response = self.cursor.execute("SELECT * FROM projects WHERE user=? AND name=?", p)
        row = response.fetchone()
        
        if row:
            p = (pname, login, )
            self.cursor.execute("UPDATE users SET project=? WHERE login=?", p)
            self.conn.commit()
            return (True, 'project set')
        else:
            return (False, 'the user does not own this project')


    def delete_project(self, login, pname):
        if not login:
            raise ConfigError, "You must pass a login to create a project"
        if not pname:
            raise ConfigError, "You must pass a project name to create a project"
        user = self.get_user_for_login(login)

        if not user:
            return (False, "Could not find a user for login %s" % login)

        # create a path name for the project
        ppath = hashlib.md5(pname).hexdigest()
        path = self.users_data_dir + '/userdata/'+ user["path"] + '/' + ppath
        
        p = (login, pname, )
        response = self.cursor.execute("SELECT * FROM projects WHERE user=? AND name=?", p)
        row = response.fetchone()
        
        if row:
            p = (None, login, )
            self.cursor.execute("UPDATE users SET project=? WHERE login=?", p)
            p = (login, pname, )
            self.cursor.execute("DELETE FROM projects WHERE user=? AND name=? ", p)
            self.conn.commit()
            p = (pname, )
            self.cursor.execute("DELETE FROM views WHERE project=? ", p)
            self.conn.commit()

            if os.path.exists(path):
                shutil.rmtree(path, ignore_errors=True)
            else:
                print path
            
            return (True, 'project deleted')
        else:
            return (False, 'the user does not own this project')

    ######################################
    # VIEWS
    ######################################
    def get_view(self, vname, token=None):
        # get the view
        p = (vname, )
        response = self.cursor.execute("SELECT * FROM views WHERE name=?", p)
        view = response.fetchone()
        if not view:
            return (False, "a view with name %s does not exist" % vname)

        # get the project for this view
        p = (view['project'], )
        response = self.cursor.execute("SELECT * FROM projects WHERE name=?", p)
        row = response.fetchone()
        if row:           
            # create the path and add it to the return structure
            path = row['path']
            
            # get the user of the project
            user = self.get_user_for_login(row['user'])

            if not user:
                return (False, "Could not find a user for this project")
            
            view['path'] = user['path'] + '/' + path
        else:
            # the project is gone, clean up this reference
            p = (vname, )
            response = self.cursor.execute("DELETE FROM views WHERE name=?", p)
            self.conn.commit()
            
            return (False, "the project for this view does not exist")

        # check if we have a token and if so see if it matches
        if token:
            if view['token'] == token:
                return (True, view)
            else:
                return (False, "invalid token")

        # otherwise check if the view is public
        if view['public'] == 1:
            return (True, view)
        else:
            return (False, "a token is required to access this view")
        
        return True


    def delete_view(self, login, vname):
        # get the user
        user = self.get_user_for_login(login)

        if not user:
            return (False, "Could not find a user for login %s" % login)

        # get the view
        p = (vname, )
        response = self.cursor.execute("SELECT * FROM views WHERE name=?", p)
        row = response.fetchone()
        if not row:
            return (False, "a view with name %s does not exist" % vname)

        response = self.cursor.execute("DELETE FROM views WHERE name=?", p)
        self.conn.commit()
        
        return (True, "view deleted")

    def create_view(self, login, vname, pname, public=1):
        # get the user
        user = self.get_user_for_login(login)

        if not user:
            return (False, "Could not find a user for login %s" % login)
                
        # check if the view name is unique
        p = (vname, )
        response = self.cursor.execute("SELECT * FROM views WHERE name=?", p)
        row = response.fetchone()
        if row:
            return (False, "view name already taken")

        # check if the project is owned by the user
        p = (pname, login)
        response = self.cursor.execute("SELECT * FROM projects WHERE name=? AND user=?", p)
        row = response.fetchone()
        if not row:
            return (False, "The user does not own this project")

        # create a token
        token = ''.join(random.choice(string.ascii_letters + string.digits) for _ in range(32))
        
        # create the db entry
        p = (vname, pname, public, token, )
        response = self.cursor.execute("INSERT INTO views (name, project, public, token) values (?, ?, ?, ?)", p)
        self.conn.commit()
        
        return (True, token)

    ######################################
    # REQUEST SECTION
    ######################################

    def check_user(self, request):
        # check if we have a cookie
        if request.get_cookie('anvioSession'):

            # we have a cookie, check if it is valid
            retval = self.get_user_for_token(request.get_cookie('anvioSession'))
            if retval[0]:
                user = retval[1]
                if user.has_key('project_path'):
                    basepath = self.users_data_dir + '/userdata/' + user['path'] + '/' + user['project_path'] + '/'
                    args = copy.deepcopy(self.args)
                    args.tree = basepath + 'treeFile'
                    args.fasta_file = basepath + 'fastaFile'
                    args.view_data = basepath + 'dataFile'
                    args.title = user['project']
                    args.read_only = False
                    args.profile_db = basepath + 'profile.db'
                    args.additional_layers = None
                    addFile = basepath + 'additionalFile'
                    if os.path.isfile(addFile):
                        args.additional_layers = addFile
                    
                    d = interactive.InputHandler(args)
                    return [ True, d, args ]
                else:
                    return [ False ]
            else:
                return [ False ]
        else:
            return [ False ]


    def check_view(self, request):
        if request.get_cookie('anvioView'):
            p = request.get_cookie('anvioView').split('|')
            retval = userdb.get_view(p[0], p[1])
            if retval[0]:
                args = self.args
                basepath = self.users_data_dir + '/userdata/' + retval[1]['path'] + '/'
                args.tree = basepath + 'treeFile'
                args.fasta_file = basepath + 'fastaFile'
                args.view_data = basepath + 'dataFile'
                args.title = retval[1]['project']
                args.read_only = True

                d = interactive.InputHandler(args)

                return [ True, d, args ]
            else:
                return [ False ]
        else:
            return [ False ]


    def set_user_data(self, request, data):
        retval = self.check_view(request)
        if retval[0]:
            return retval[1]
        retval = self.check_user(request)
        if retval[0]:
            return [ retval[1], retval[2] ]

        return [ data, self.orig_args ]

        
def dict_factory(cursor, row):
    d = {}
    for idx, col in enumerate(cursor.description):
        d[col[0]] = row[idx]
            
    return d
